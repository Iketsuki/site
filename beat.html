<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rhythm Practice Maker</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        /* Custom Scrollbar for the Sequencer */
        .sequencer-scroll::-webkit-scrollbar {
            height: 12px;
        }
        .sequencer-scroll::-webkit-scrollbar-track {
            background: #1f2937;
            border-radius: 6px;
        }
        .sequencer-scroll::-webkit-scrollbar-thumb {
            background: #4b5563;
            border-radius: 6px;
        }
        .sequencer-scroll::-webkit-scrollbar-thumb:hover {
            background: #6b7280;
        }

        /* Beat Cell Animation */
        .beat-cell {
            transition: all 0.1s ease;
        }
        .beat-cell.active {
            transform: scale(0.95);
        }
        .playing-head {
            border: 2px solid #ef4444 !important;
            box-shadow: 0 0 10px #ef4444;
            z-index: 10;
        }
    </style>
</head>
<body class="bg-gray-900 text-gray-100 font-sans min-h-screen flex flex-col">

    <!-- Header -->
    <header class="bg-gray-800 border-b border-gray-700 p-4 sticky top-0 z-20 shadow-md">
        <div class="max-w-7xl mx-auto flex flex-col md:flex-row justify-between items-center gap-4">
            <div class="flex items-center gap-3">
                <i class="fa-solid fa-music text-blue-500 text-2xl"></i>
                <h1 class="text-xl font-bold tracking-wide">Rhythm<span class="text-blue-500">Maker</span></h1>
            </div>
            
            <!-- Main Controls -->
            <div class="flex items-center gap-4 bg-gray-900 p-2 rounded-lg border border-gray-700">
                <button id="playBtn" class="w-12 h-12 flex items-center justify-center rounded-full bg-green-600 hover:bg-green-500 text-white transition-colors">
                    <i class="fa-solid fa-play"></i>
                </button>
                <button id="stopBtn" class="w-12 h-12 flex items-center justify-center rounded-full bg-gray-700 hover:bg-gray-600 text-white transition-colors">
                    <i class="fa-solid fa-stop"></i>
                </button>
                <button id="loopBtn" class="w-12 h-12 flex items-center justify-center rounded-full bg-gray-700 text-gray-400 hover:text-blue-400 transition-colors border border-transparent">
                    <i class="fa-solid fa-repeat"></i>
                </button>
                <div class="h-8 w-px bg-gray-700 mx-1"></div>
                <div class="flex flex-col items-center w-20">
                    <span class="text-xs text-gray-400">BPM</span>
                    <input type="number" id="bpmInput" value="60" min="20" max="300" class="w-full bg-transparent text-center font-mono font-bold text-lg focus:outline-none text-blue-400">
                </div>
            </div>

            <div class="flex gap-2">
                 <button id="exportImgBtn" class="px-3 py-2 bg-indigo-600 hover:bg-indigo-500 rounded text-sm font-medium flex items-center gap-2">
                    <i class="fa-solid fa-image"></i> <span class="hidden sm:inline">PNG</span>
                </button>
                <button id="exportAudioBtn" class="px-3 py-2 bg-orange-600 hover:bg-orange-500 rounded text-sm font-medium flex items-center gap-2">
                    <i class="fa-solid fa-file-audio"></i> <span class="hidden sm:inline">WAV</span>
                </button>
            </div>
        </div>
    </header>

    <!-- Parameters Panel -->
    <section class="bg-gray-800 border-b border-gray-700 p-4">
        <div class="max-w-7xl mx-auto grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
            
            <!-- Time Sig -->
            <div class="flex flex-col gap-1">
                <label class="text-gray-400">Time Signature</label>
                <div class="flex items-center gap-2">
                    <select id="timeSigNum" class="bg-gray-700 border border-gray-600 rounded px-2 py-1 flex-1">
                        <option value="2">2</option>
                        <option value="3">3</option>
                        <option value="4" selected>4</option>
                        <option value="5">5</option>
                        <option value="6">6</option>
                        <option value="7">7</option>
                        <option value="9">9</option>
                        <option value="12">12</option>
                    </select>
                    <span class="text-gray-500">/</span>
                    <select id="timeSigDenom" class="bg-gray-700 border border-gray-600 rounded px-2 py-1 flex-1">
                        <option value="2">2</option>
                        <option value="4" selected>4</option>
                        <option value="8">8</option>
                    </select>
                </div>
            </div>

            <!-- Resolution -->
            <div class="flex flex-col gap-1">
                <label class="text-gray-400">Smallest Beat</label>
                <select id="subdivision" class="bg-gray-700 border border-gray-600 rounded px-3 py-1 w-full">
                    <option value="1">1/1 (Whole)</option>
                    <option value="2">1/2 (Half)</option>
                    <option value="4">1/4 (Quarter)</option>
                    <option value="8" selected>1/8 (Eighth)</option>
                    <option value="16">1/16 (Sixteenth)</option>
                    <option value="32">1/32 (Thirty-second)</option>
                </select>
            </div>

            <!-- Bars -->
            <div class="flex flex-col gap-1">
                <label class="text-gray-400">Number of Bars</label>
                <input type="number" id="barCount" value="4" min="1" max="16" class="bg-gray-700 border border-gray-600 rounded px-3 py-1 w-full">
            </div>

            <!-- Actions -->
            <div class="flex flex-col justify-end">
                <button id="applySettingsBtn" class="w-full bg-blue-600 hover:bg-blue-500 text-white font-medium py-1 px-3 rounded transition-colors">
                    Reset & Apply
                </button>
            </div>
        </div>
    </section>

    <!-- Sequencer Grid Area -->
    <main class="flex-1 p-4 md:p-8 overflow-hidden flex flex-col relative">
        <div class="sequencer-scroll overflow-x-auto overflow-y-hidden flex-1 border border-gray-700 bg-gray-900 rounded-lg shadow-inner relative">
            <div id="gridContainer" class="flex h-full min-w-max p-4 gap-1">
                <!-- Grid items generated here -->
            </div>
        </div>
        <p class="text-center text-gray-500 text-sm mt-4">
            <i class="fa-solid fa-hand-pointer"></i> Tap cells to toggle beats. 
            <span class="inline-block w-3 h-3 bg-blue-500 rounded-sm ml-2"></span> Note
            <span class="inline-block w-3 h-3 bg-gray-800 border border-gray-600 rounded-sm ml-2"></span> Rest
        </p>
    </main>

    <!-- Hidden Canvas for Export -->
    <canvas id="exportCanvas" class="hidden"></canvas>

    <!-- Modal / Overlay for processing -->
    <div id="loadingOverlay" class="fixed inset-0 bg-black bg-opacity-80 z-50 hidden flex items-center justify-center flex-col">
        <div class="w-12 h-12 border-4 border-blue-500 border-t-transparent rounded-full animate-spin mb-4"></div>
        <p class="text-white text-lg font-medium" id="loadingText">Processing...</p>
    </div>

<script>
/**
 * AUDIO ENGINE & APP LOGIC
 */

const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
let isPlaying = false;
let isLooping = false;
let currentStep = 0;
let nextNoteTime = 0.0;
let timerID;
let sequence = []; // Array of 0 (rest) or 1 (note)
let stepsPerBar = 0;
let totalSteps = 0;

// DOM Elements
const gridContainer = document.getElementById('gridContainer');
const playBtn = document.getElementById('playBtn');
const stopBtn = document.getElementById('stopBtn');
const loopBtn = document.getElementById('loopBtn');
const bpmInput = document.getElementById('bpmInput');
const timeSigNum = document.getElementById('timeSigNum');
const timeSigDenom = document.getElementById('timeSigDenom');
const subdivision = document.getElementById('subdivision');
const barCountInput = document.getElementById('barCount');
const applyBtn = document.getElementById('applySettingsBtn');
const loadingOverlay = document.getElementById('loadingOverlay');
const loadingText = document.getElementById('loadingText');

// Init
generateGrid();

// Event Listeners
applyBtn.addEventListener('click', () => {
    stopPlayback();
    generateGrid();
});

playBtn.addEventListener('click', togglePlay);
stopBtn.addEventListener('click', stopPlayback);
loopBtn.addEventListener('click', () => {
    isLooping = !isLooping;
    loopBtn.classList.toggle('text-blue-400', isLooping);
    loopBtn.classList.toggle('border-blue-400', isLooping);
});
document.getElementById('exportImgBtn').addEventListener('click', exportToImage);
document.getElementById('exportAudioBtn').addEventListener('click', exportToAudio);

// --- Core Grid Logic ---

function generateGrid() {
    const num = parseInt(timeSigNum.value);
    const den = parseInt(timeSigDenom.value);
    const sub = parseInt(subdivision.value);
    const bars = parseInt(barCountInput.value);

    // Calculate Grid Dimensions
    // Example: 4/4 time, 1/8 subdivision. 
    // Beats per bar = 4. 
    // Value of a beat = 1/4. 
    // Smallest unit = 1/8.
    // Multiplier = (1/4) / (1/8) = 2 steps per beat.
    // Total steps per bar = 4 * 2 = 8.
    
    // Simpler math: (Numerator * Subdivision) / Denominator
    // 4/4 @ 1/8 => (4 * 8) / 4 = 8 steps.
    // 6/8 @ 1/16 => (6 * 16) / 8 = 12 steps.
    
    stepsPerBar = (num * sub) / den;
    
    // Validate reasonable density
    if (stepsPerBar % 1 !== 0) {
        alert("Invalid Time Signature/Subdivision combination. Please adjust.");
        return;
    }

    totalSteps = stepsPerBar * bars;
    sequence = new Array(totalSteps).fill(0); // 0 = Rest, 1 = Beat

    renderGridUI(bars, stepsPerBar, sub);
}

function renderGridUI(bars, stepsPerBar, sub) {
    gridContainer.innerHTML = '';

    // Step width calculation for responsiveness
    // We want bars to look distinct.
    
    for (let b = 0; b < bars; b++) {
        const barDiv = document.createElement('div');
        barDiv.className = 'flex flex-col h-full bg-gray-800 rounded-md border border-gray-600 overflow-hidden shrink-0 mr-2';
        // barDiv.style.minWidth = `${stepsPerBar * 40}px`; // Min width to ensure touch targets

        // Bar Header
        const barHeader = document.createElement('div');
        barHeader.className = 'bg-gray-700 text-xs text-center py-1 text-gray-400 font-mono border-b border-gray-600';
        barHeader.innerText = `BAR ${b + 1}`;
        barDiv.appendChild(barHeader);

        // Steps Container
        const stepsContainer = document.createElement('div');
        stepsContainer.className = 'flex flex-1 p-1 gap-1 items-center justify-center';
        
        for (let s = 0; s < stepsPerBar; s++) {
            const absoluteStepIndex = (b * stepsPerBar) + s;
            
            const cell = document.createElement('button');
            cell.dataset.index = absoluteStepIndex;
            cell.className = `beat-cell w-10 md:w-14 h-24 md:h-32 rounded flex items-center justify-center text-xl transition-colors border border-gray-600 bg-gray-900 text-gray-600 hover:bg-gray-800 focus:outline-none`;
            
            // Visual marking for downbeats (simplified logic)
            // If subdivision equals denominator, every step is a beat.
            // If subdivision is 2x denominator, every 2nd step is a beat.
            const ratio = parseInt(subdivision.value) / parseInt(timeSigDenom.value);
            if (s % ratio === 0) {
                cell.classList.add('border-t-4', 'border-t-gray-500'); // Slight visual marker for beats
            }

            cell.innerHTML = '<i class="fa-solid fa-minus opacity-30"></i>'; // Rest symbol

            cell.onclick = () => toggleNote(absoluteStepIndex, cell);
            
            stepsContainer.appendChild(cell);
        }
        
        barDiv.appendChild(stepsContainer);
        gridContainer.appendChild(barDiv);
    }
}

function toggleNote(index, element) {
    if (sequence[index] === 0) {
        sequence[index] = 1;
        // Visual Update
        element.classList.remove('bg-gray-900', 'text-gray-600');
        element.classList.add('bg-blue-600', 'text-white', 'border-blue-400');
        element.innerHTML = '<i class="fa-solid fa-music"></i>';
        
        // Preview Sound
        playClick(audioCtx, audioCtx.currentTime);
    } else {
        sequence[index] = 0;
        // Visual Update
        element.classList.remove('bg-blue-600', 'text-white', 'border-blue-400');
        element.classList.add('bg-gray-900', 'text-gray-600');
        element.innerHTML = '<i class="fa-solid fa-minus opacity-30"></i>';
    }
}

// --- Audio Engine ---

function playClick(context, time, isDownbeat = false) {
    const osc = context.createOscillator();
    const gainNode = context.createGain();

    osc.connect(gainNode);
    gainNode.connect(context.destination);

    // Woodblock-ish sound
    if (isDownbeat) {
        osc.frequency.setValueAtTime(1200, time);
        osc.frequency.exponentialRampToValueAtTime(600, time + 0.1);
    } else {
        osc.frequency.setValueAtTime(800, time);
        osc.frequency.exponentialRampToValueAtTime(400, time + 0.1);
    }
    
    gainNode.gain.setValueAtTime(0.7, time);
    gainNode.gain.exponentialRampToValueAtTime(0.01, time + 0.1);

    osc.start(time);
    osc.stop(time + 0.1);
}

function scheduler() {
    // Lookahead of 0.1 seconds
    while (nextNoteTime < audioCtx.currentTime + 0.1) {
        scheduleNote(currentStep, nextNoteTime);
        advanceNote();
    }
    timerID = requestAnimationFrame(scheduler);
}

function scheduleNote(stepNumber, time) {
    // UI Update (Visual Playhead)
    // We use requestAnimationFrame for UI to keep it synced visually but loose
    const drawTime = (time - audioCtx.currentTime) * 1000;
    setTimeout(() => {
        highlightStep(stepNumber);
    }, Math.max(0, drawTime));

    if (sequence[stepNumber] === 1) {
        const isBarStart = stepNumber % stepsPerBar === 0;
        playClick(audioCtx, time, isBarStart);
    }
}

function advanceNote() {
    // Seconds per beat = 60 / BPM
    // Seconds per step? 
    // BPM is quarter notes usually. 
    // Resolution factor needed.
    // If subdivision is 8 (eighth notes), that's 2 steps per quarter note.
    
    const bpm = parseInt(bpmInput.value);
    const sub = parseInt(subdivision.value);
    
    // Standard BPM is based on Quarter notes (1/4)
    // Duration of a quarter note = 60 / BPM
    // Duration of our step (e.g. 1/8) = (60/BPM) * (4 / sub)
    
    const secondsPerStep = (60.0 / bpm) * (4.0 / sub);
    
    nextNoteTime += secondsPerStep;
    currentStep++;

    if (currentStep >= totalSteps) {
        if (isLooping) {
            currentStep = 0;
        } else {
            // Stop scheduling, but let the last note play out
            // We'll clear the timer in the scheduler check usually, 
            // but here we just stop advancing.
            // Actually, best to just pause.
            // But scheduler loop runs continuously. 
            // Let's handle stop in UI sync.
             setTimeout(() => {
                 if(!isLooping && currentStep >= totalSteps) stopPlayback();
             }, (secondsPerStep * 1000) + 100); 
        }
    }
}

function highlightStep(step) {
    // Remove previous highlights
    document.querySelectorAll('.beat-cell').forEach(el => el.classList.remove('playing-head'));
    
    // Add new (if valid)
    if (step < totalSteps) {
        const el = document.querySelector(`.beat-cell[data-index="${step}"]`);
        if (el) {
            el.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
            el.classList.add('playing-head');
        }
    }
}

async function togglePlay() {
    if (audioCtx.state === 'suspended') {
        await audioCtx.resume();
    }

    if (isPlaying) {
        stopPlayback();
    } else {
        isPlaying = true;
        currentStep = 0;
        nextNoteTime = audioCtx.currentTime + 0.05;
        playBtn.innerHTML = '<i class="fa-solid fa-pause"></i>';
        scheduler();
    }
}

function stopPlayback() {
    isPlaying = false;
    cancelAnimationFrame(timerID);
    playBtn.innerHTML = '<i class="fa-solid fa-play"></i>';
    document.querySelectorAll('.beat-cell').forEach(el => el.classList.remove('playing-head'));
}

// --- Export Functions ---

async function exportToAudio() {
    showLoading(true, "Rendering Audio...");
    
    const bpm = parseInt(bpmInput.value);
    const sub = parseInt(subdivision.value);
    const secondsPerStep = (60.0 / bpm) * (4.0 / sub);
    const totalDuration = secondsPerStep * totalSteps + 0.5; // + tail

    // 1. Setup Offline Context
    const offlineCtx = new OfflineAudioContext(1, 44100 * totalDuration, 44100);

    // 2. Schedule all notes
    for (let i = 0; i < sequence.length; i++) {
        if (sequence[i] === 1) {
            const time = i * secondsPerStep;
            const isBarStart = i % stepsPerBar === 0;
            playClick(offlineCtx, time, isBarStart);
        }
    }

    // 3. Render
    try {
        const renderedBuffer = await offlineCtx.startRendering();
        const wavBlob = bufferToWave(renderedBuffer, totalDuration * 44100);
        const url = URL.createObjectURL(wavBlob);
        
        const a = document.createElement('a');
        a.style.display = 'none';
        a.href = url;
        a.download = 'rhythm_practice.wav';
        document.body.appendChild(a);
        a.click();
        window.URL.revokeObjectURL(url);
    } catch(e) {
        console.error(e);
        alert("Error exporting audio.");
    } finally {
        showLoading(false);
    }
}

// Helper: Convert AudioBuffer to WAV Blob
function bufferToWave(abuffer, len) {
    const numOfChan = abuffer.numberOfChannels;
    const length = len * numOfChan * 2 + 44;
    const buffer = new ArrayBuffer(length);
    const view = new DataView(buffer);
    const channels = [];
    let i;
    let sample;
    let offset = 0;
    let pos = 0;

    // write WAVE header
    setUint32(0x46464952); // "RIFF"
    setUint32(length - 8); // file length - 8
    setUint32(0x45564157); // "WAVE"

    setUint32(0x20746d66); // "fmt " chunk
    setUint32(16); // length = 16
    setUint16(1); // PCM (uncompressed)
    setUint16(numOfChan);
    setUint32(abuffer.sampleRate);
    setUint32(abuffer.sampleRate * 2 * numOfChan); // avg. bytes/sec
    setUint16(numOfChan * 2); // block-align
    setUint16(16); // 16-bit (hardcoded in this example)

    setUint32(0x61746164); // "data" - chunk
    setUint32(length - pos - 4); // chunk length

    // write interleaved data
    for (i = 0; i < abuffer.numberOfChannels; i++) channels.push(abuffer.getChannelData(i));

    while (pos < len) {
        for (i = 0; i < numOfChan; i++) {
            // clamp
            sample = Math.max(-1, Math.min(1, channels[i][pos])); 
            // scale to 16-bit signed int
            sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767) | 0; 
            view.setInt16(44 + offset, sample, true);
            offset += 2;
        }
        pos++;
    }

    return new Blob([buffer], { type: "audio/wav" });

    function setUint16(data) { view.setUint16(pos, data, true); pos += 2; }
    function setUint32(data) { view.setUint32(pos, data, true); pos += 4; }
}

function exportToImage() {
    showLoading(true, "Generating Image...");
    
    setTimeout(() => {
        const canvas = document.getElementById('exportCanvas');
        const ctx = canvas.getContext('2d');
        
        // Settings
        const boxSize = 40;
        const gap = 5;
        const barMargin = 20;
        const width = (stepsPerBar * (boxSize + gap) * parseInt(barCountInput.value)) + (parseInt(barCountInput.value) * barMargin) + 100;
        const height = 200;
        
        // Setup Canvas
        canvas.width = width;
        canvas.height = height;
        
        // Background
        ctx.fillStyle = "#ffffff";
        ctx.fillRect(0, 0, width, height);
        
        // Title Info
        ctx.fillStyle = "#000000";
        ctx.font = "bold 20px Arial";
        ctx.fillText(`Rhythm Practice: ${bpmInput.value} BPM | ${timeSigNum.value}/${timeSigDenom.value}`, 20, 40);
        
        // Draw Grid
        let currentX = 20;
        let currentY = 80;
        
        for (let i = 0; i < sequence.length; i++) {
            // New bar spacing
            if (i > 0 && i % stepsPerBar === 0) {
                // Draw bar line
                ctx.beginPath();
                ctx.moveTo(currentX + (barMargin/2) - gap, currentY - 10);
                ctx.lineTo(currentX + (barMargin/2) - gap, currentY + boxSize + 10);
                ctx.strokeStyle = "#999";
                ctx.stroke();
                
                currentX += barMargin;
            }
            
            // Draw Box
            if (sequence[i] === 1) {
                ctx.fillStyle = "#2563eb"; // Blue for note
                ctx.fillRect(currentX, currentY, boxSize, boxSize);
                
                // Draw Note Stem (simple visual)
                ctx.strokeStyle = "white";
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(currentX + 10, currentY + 30);
                ctx.lineTo(currentX + 30, currentY + 10);
                ctx.stroke();
            } else {
                ctx.strokeStyle = "#ccc";
                ctx.lineWidth = 2;
                ctx.strokeRect(currentX, currentY, boxSize, boxSize);
                
                // Draw Rest Dash
                ctx.fillStyle = "#ccc";
                ctx.fillRect(currentX + 10, currentY + (boxSize/2) - 2, boxSize - 20, 4);
            }
            
            // Draw subdivision count below (1 e & a...) - Simplified to numbers
            ctx.fillStyle = "#666";
            ctx.font = "10px Arial";
            const stepInBar = (i % stepsPerBar) + 1;
            ctx.fillText(stepInBar, currentX + boxSize/3, currentY + boxSize + 15);
            
            currentX += boxSize + gap;
        }
        
        // Export
        const imgUrl = canvas.toDataURL("image/png");
        const a = document.createElement('a');
        a.href = imgUrl;
        a.download = 'rhythm_pattern.png';
        a.click();
        
        showLoading(false);
    }, 100);
}

function showLoading(show, text = "") {
    if (show) {
        loadingText.innerText = text;
        loadingOverlay.classList.remove('hidden');
        loadingOverlay.classList.add('flex');
    } else {
        loadingOverlay.classList.add('hidden');
        loadingOverlay.classList.remove('flex');
    }
}

</script>
</body>
</html>
