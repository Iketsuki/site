<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Congruent & Similar Triangles Lab</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            touch-action: none;
            overflow: hidden;
            background-color: #f1f5f9;
            font-family: system-ui, -apple-system, sans-serif;
        }
        .canvas-container {
            position: relative;
            width: 100%;
            height: 100vh;
            cursor: grab;
        }
        .canvas-container:active { cursor: grabbing; }
        
        canvas { display: block; width: 100%; height: 100%; }

        .control-panel {
            backdrop-filter: blur(20px);
            background-color: rgba(255, 255, 255, 0.95);
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 10px 0 40px rgba(0,0,0,0.1);
            z-index: 100;
        }
        .hidden-panel { transform: translateX(-100%); }

        .fab-toggle {
            position: fixed;
            bottom: 1.5rem;
            right: 1.5rem;
            width: 3.5rem;
            height: 3.5rem;
            background: white;
            border-radius: 9999px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 10px 25px rgba(0,0,0,0.15);
            cursor: pointer;
            z-index: 150;
            border: 1px solid #e2e8f0;
            transition: all 0.2s;
        }
        .fab-toggle:active { scale: 0.9; background-color: #f8fafc; }

        .toggle-chip {
            @apply flex-1 py-1.5 text-[9px] font-black rounded transition-all uppercase text-center cursor-pointer select-none shadow-sm active:scale-95 text-white flex items-center justify-center gap-1;
        }
        .toggle-chip.active { background: linear-gradient(to bottom, #16a34a, #15803d); border: 1px solid #14532d; }
        .toggle-chip.inactive { background: linear-gradient(to bottom, #ef4444, #dc2626); border: 1px solid #991b1b; }

        .bulk-btn { @apply text-[8px] px-1.5 py-0.5 rounded bg-slate-200 hover:bg-slate-300 text-slate-700 font-black uppercase transition-colors; }
        input[type=range] { @apply accent-blue-600; }
        .action-btn { @apply px-3 py-2 bg-white border border-slate-200 rounded-lg text-[10px] font-black uppercase shadow-sm text-slate-700; }
        .name-group-input { @apply w-full px-3 py-1.5 bg-white border border-slate-200 rounded text-xs font-bold uppercase tracking-[0.2em] text-center; }
    </style>
</head>
<body>

<div class="canvas-container" id="container">
    <canvas id="geometryCanvas"></canvas>

    <div id="sidebar" class="control-panel fixed left-0 top-0 h-full w-72 p-5 overflow-y-auto border-r border-slate-200">
        <div class="mb-6 flex items-center justify-between">
            <h1 class="text-lg font-black tracking-tight text-slate-800">Triangle Lab</h1>
            <button onclick="resetAll()" class="text-[10px] bg-red-50 text-red-600 px-3 py-1 rounded-lg border border-red-100 font-black uppercase hover:bg-red-100 transition-colors shadow-sm">Reset</button>
        </div>

        <div class="space-y-6">
            <details class="group">
                <summary class="flex items-center justify-between py-2 cursor-pointer border-b border-slate-100 mb-2 list-none">
                    <h2 class="text-xs font-black uppercase text-slate-400">Names & Font</h2>
                    <svg class="w-4 h-4 group-open:rotate-180 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path d="M19 9l-7 7-7-7"/></svg>
                </summary>
                <div class="pt-2 space-y-4">
                    <div>
                        <div class="flex justify-between items-center mb-1">
                            <h3 class="text-[10px] font-black text-slate-400 uppercase">Font Size</h3>
                            <span id="fontVal" class="text-xs font-black text-blue-600">14</span>
                        </div>
                        <input type="range" id="fontSlider" min="10" max="24" value="14" class="w-full" oninput="updateFontSize(this.value)">
                    </div>
                    <div class="space-y-2">
                        <input type="text" id="nameTri1" maxlength="3" value="ABC" oninput="updateFullNames(0, this.value)" class="name-group-input border-blue-200 text-blue-700">
                        <input type="text" id="nameTri2" maxlength="3" value="DEF" oninput="updateFullNames(1, this.value)" class="name-group-input border-purple-200 text-purple-700">
                    </div>
                </div>
            </details>

            <details open class="group">
                <summary class="flex items-center justify-between py-2 cursor-pointer border-b border-slate-100 mb-2 list-none">
                    <h2 class="text-xs font-black uppercase text-slate-400">Lock Constraints</h2>
                    <svg class="w-4 h-4 group-open:rotate-180 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path d="M19 9l-7 7-7-7"/></svg>
                </summary>
                <div class="pt-2 space-y-4">
                    <div>
                        <div class="flex items-center justify-between mb-2">
                            <p class="text-[10px] font-black text-slate-500 uppercase">Lock Sides</p>
                            <div class="flex gap-1"><button onclick="bulkSet('c', 'side', true)" class="bulk-btn">All</button><button onclick="bulkSet('c', 'side', false)" class="bulk-btn">None</button></div>
                        </div>
                        <div class="flex gap-1" id="c-side-container"></div>
                    </div>
                    <div>
                        <div class="flex items-center justify-between mb-2">
                            <p class="text-[10px] font-black text-slate-500 uppercase">Lock Angles</p>
                            <div class="flex gap-1"><button onclick="bulkSet('c', 'angle', true)" class="bulk-btn">All</button><button onclick="bulkSet('c', 'angle', false)" class="bulk-btn">None</button></div>
                        </div>
                        <div class="flex gap-1" id="c-angle-container"></div>
                    </div>
                </div>
            </details>

            <details open class="group">
                <summary class="flex items-center justify-between py-2 cursor-pointer border-b border-slate-100 mb-2 list-none">
                    <h2 class="text-xs font-black uppercase text-slate-400">Visual Controls</h2>
                    <svg class="w-4 h-4 group-open:rotate-180 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path d="M19 9l-7 7-7-7"/></svg>
                </summary>
                <div class="pt-2 space-y-4">
                    <div>
                        <p class="text-[9px] font-black text-blue-500 uppercase mb-2">ABC Visibility</p>
                        <div class="flex gap-1 mb-1" id="v1-side-container"></div>
                        <div class="flex gap-1" id="v1-angle-container"></div>
                    </div>
                    <hr class="border-slate-100">
                    <div>
                        <p class="text-[9px] font-black text-purple-500 uppercase mb-2">DEF Visibility</p>
                        <div class="flex gap-1 mb-1" id="v2-side-container"></div>
                        <div class="flex gap-1" id="v2-angle-container"></div>
                    </div>
                </div>
            </details>

            <details open class="group">
                <summary class="flex items-center justify-between py-2 cursor-pointer border-b border-slate-100 mb-2 list-none">
                    <h2 class="text-xs font-black uppercase text-slate-400">Transformations</h2>
                    <svg class="w-4 h-4 group-open:rotate-180 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path d="M19 9l-7 7-7-7"/></svg>
                </summary>
                <div class="pt-2 space-y-4">
                    <div class="flex gap-2"><button onclick="flipDEF('h')" class="action-btn flex-1">Flip H</button><button onclick="flipDEF('v')" class="action-btn flex-1">Flip V</button></div>
                    <div class="flex items-center justify-between p-3 bg-slate-100 rounded-xl">
                        <span class="text-[10px] font-black text-slate-600 uppercase">Similarity Sync</span>
                        <button id="lockBtn" onclick="toggleLock()" class="px-3 py-1.5 bg-green-600 text-white rounded-lg text-[10px] font-black uppercase shadow-md active:scale-95">Linked</button>
                    </div>
                    <div>
                        <div class="flex justify-between items-center mb-1">
                            <h3 class="text-[10px] font-black text-slate-400 uppercase">Scale Factor</h3>
                            <span id="scaleVal" class="text-xs font-black text-blue-600">1.0</span>
                        </div>
                        <input type="range" id="scaleSlider" min="0.2" max="3.0" step="0.01" value="1" class="w-full" oninput="updateScale(this.value)">
                    </div>
                </div>
            </details>
        </div>
    </div>

    <!-- Bottom Right Toggle -->
    <button onclick="toggleSidebar()" class="fab-toggle" id="fab">
        <svg id="toggleIcon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-slate-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />
        </svg>
    </button>

    <div class="fixed top-4 left-1/2 -translate-x-1/2 bg-white/95 backdrop-blur px-6 py-2 rounded-full shadow-2xl border border-white z-10 pointer-events-none" id="statusBox">
        <div id="statusIndicator" class="text-sm font-black flex items-center gap-2"></div>
    </div>
</div>

<script>
    const canvas = document.getElementById('geometryCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('container');
    
    let width, height;
    let sidebarOpen = true;
    let view = { x: 0, y: 0, zoom: 1 };
    let isLocked = true;
    let scaleFactor = 1.0;
    let fontSize = 14;
    let p2Rotation = 0; 
    let triangleNames = [["A", "B", "C"], ["D", "E", "F"]];
    let p2Offset = { x: 400, y: 0 };
    let visible1 = { sides: [true, true, true], angles: [true, true, true] };
    let visible2 = { sides: [true, true, true], angles: [true, true, true] };
    let constraints = { sides: [false, false, false], angles: [false, false, false] };
    let fixedValues = { sides: [0,0,0], angles: [0,0,0], winding: 1 };

    let p1 = [{ x: 250, y: 200 }, { x: 200, y: 400 }, { x: 400, y: 400 }];
    let p2 = [{ x: 650, y: 200 }, { x: 600, y: 400 }, { x: 800, y: 400 }];

    let dragData = { type: null, index: null, startX: 0, startY: 0, initialPts: [], initialScale: 1.0, startTime: 0, moved: false, pinchDist: 0 };

    function resize() {
        width = container.clientWidth;
        height = container.clientHeight;
        canvas.width = width;
        canvas.height = height;
        draw();
    }

    function toggleSidebar() {
        sidebarOpen = !sidebarOpen;
        document.getElementById('sidebar').classList.toggle('hidden-panel');
        document.getElementById('toggleIcon').innerHTML = sidebarOpen ? 
            '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12" />' :
            '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16" />';
    }

    function updateFontSize(val) {
        fontSize = parseInt(val);
        document.getElementById('fontVal').innerText = fontSize;
        draw();
    }

    function updateFullNames(tIdx, val) {
        triangleNames[tIdx] = val.toUpperCase().padEnd(3, " ").split("").slice(0, 3);
        renderControlChips();
        draw();
    }

    function toggleElement(prefix, type, index) {
        if (prefix === 'c') constraints[type + 's'][index] = !constraints[type + 's'][index];
        else if (prefix === 'v1') visible1[type + 's'][index] = !visible1[type + 's'][index];
        else if (prefix === 'v2') visible2[type + 's'][index] = !visible2[type + 's'][index];
        updateFixedValues();
        renderControlChips();
        draw();
    }

    function bulkSet(prefix, type, value) {
        if (prefix === 'c') constraints[type + 's'] = [value, value, value];
        else if (prefix === 'v1') visible1[type + 's'] = [value, value, value];
        else if (prefix === 'v2') visible2[type + 's'] = [value, value, value];
        updateFixedValues();
        renderControlChips();
        draw();
    }

    function renderControlChips() {
        const createChips = (prefix, type) => {
            const container = document.getElementById(`${prefix}-${type}-container`);
            if (!container) return;
            container.innerHTML = "";
            const targetState = prefix === 'c' ? constraints : (prefix === 'v1' ? visible1 : visible2);
            const nameIdx = prefix === 'v2' ? 1 : 0;
            for (let i = 0; i < 3; i++) {
                let label = type === 'side' ? triangleNames[nameIdx][i] + triangleNames[nameIdx][(i+1)%3] : "âˆ " + triangleNames[nameIdx][i];
                const val = targetState[type + 's'][i];
                const chip = document.createElement('div');
                chip.className = `toggle-chip ${val ? 'active' : 'inactive'}`;
                chip.innerHTML = (prefix === 'c' ? (val ? 'ðŸ”’' : 'ðŸ”“') : '') + " " + label;
                chip.onclick = (e) => { e.stopPropagation(); toggleElement(prefix, type, i); };
                container.appendChild(chip);
            }
        };
        ['c','v1','v2'].forEach(p => ['side','angle'].forEach(t => createChips(p, t)));
    }

    function flipDEF(axis) {
        const c2 = getCenter(p2);
        p2 = p2.map(p => axis === 'h' ? { x: c2.x - (p.x - c2.x), y: p.y } : { x: p.x, y: c2.y - (p.y - c2.y) });
        const c1 = getCenter(p1), curC2 = getCenter(p2);
        p2Offset = { x: curC2.x - c1.x, y: curC2.y - c1.y };
        draw();
    }

    function updateFixedValues() {
        for(let i=0; i<3; i++) {
            fixedValues.sides[i] = getDistance(p1[i], p1[(i+1)%3]);
            fixedValues.angles[i] = getAngleDegree(p1[i], p1[(i+1)%3], p1[(i+2)%3]);
        }
        fixedValues.winding = Math.sign((p1[1].x - p1[0].x) * (p1[2].y - p1[0].y) - (p1[1].y - p1[0].y) * (p1[2].x - p1[0].x));
    }

    function toggleLock() {
        isLocked = !isLocked;
        const btn = document.getElementById('lockBtn');
        btn.innerText = isLocked ? "Linked" : "Independent";
        btn.className = isLocked ? "px-3 py-1.5 bg-green-600 text-white rounded-lg text-[10px] font-black uppercase shadow-md active:scale-95" : "px-3 py-1.5 bg-orange-600 text-white rounded-lg text-[10px] font-black uppercase shadow-md active:scale-95";
        if (isLocked) syncTriangles();
        updateStatus(); draw();
    }

    function resetAll() {
        view = { x: 0, y: 0, zoom: 1 }; isLocked = true; scaleFactor = 1.0;
        p1 = [{ x: 250, y: 200 }, { x: 200, y: 400 }, { x: 400, y: 400 }];
        p2Offset = { x: 400, y: 0 }; p2Rotation = 0;
        triangleNames = [["A", "B", "C"], ["D", "E", "F"]];
        visible1 = { sides: [true, true, true], angles: [true, true, true] };
        visible2 = { sides: [true, true, true], angles: [true, true, true] };
        constraints = { sides: [false, false, false], angles: [false, false, false] };
        updateFontSize(14); renderControlChips(); updateFixedValues(); updateScale(1); draw();
    }

    function syncTriangles() {
        const c1 = getCenter(p1);
        p2 = p1.map(p => {
            let dx = p.x - c1.x, dy = p.y - c1.y;
            let rx = dx * Math.cos(p2Rotation) - dy * Math.sin(p2Rotation);
            let ry = dx * Math.sin(p2Rotation) + dy * Math.cos(p2Rotation);
            return { x: rx * scaleFactor + c1.x + p2Offset.x, y: ry * scaleFactor + c1.y + p2Offset.y };
        });
    }

    function updateScale(val) {
        scaleFactor = parseFloat(val);
        document.getElementById('scaleVal').innerText = scaleFactor.toFixed(2);
        document.getElementById('scaleSlider').value = scaleFactor;
        syncTriangles(); updateStatus(); draw();
    }

    function getCenter(pts) { return { x: (pts[0].x + pts[1].x + pts[2].x) / 3, y: (pts[0].y + pts[1].y + pts[2].y) / 3 }; }
    function getDistance(a, b) { return Math.sqrt((b.x-a.x)**2 + (b.y-a.y)**2); }
    function getAngleDegree(p, next, prev) {
        const a = getDistance(next, prev), b = getDistance(p, prev), c = getDistance(p, next);
        const cos = (b*b + c*c - a*a) / (2*b*c);
        return Math.acos(Math.max(-1, Math.min(1, cos))) * 180 / Math.PI;
    }

    function distToSegment(p, a, b) {
        const l2 = (a.x-b.x)**2 + (a.y-b.y)**2;
        if (l2 === 0) return getDistance(p, a);
        let t = Math.max(0, Math.min(1, ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2));
        return getDistance(p, { x: a.x + t * (b.x - a.x), y: a.y + t * (b.y - a.y) });
    }

    function solveConstraints(index, mousePos, targetTriangle) {
        if (constraints.angles[index]) return;
        const nextIdx = (index + 1) % 3, prevIdx = (index + 2) % 3;
        const pts = targetTriangle === 1 ? p1 : p2;
        const isAA = constraints.angles.filter(v => v).length >= 2;
        const isSSS = constraints.sides.every(v => v);

        if (targetTriangle === 2 && (isSSS || isAA)) {
            const c2 = getCenter(pts);
            const d_old = getDistance(c2, dragData.initialPts[index]);
            const d_new = getDistance(c2, mousePos);
            const ang_old = Math.atan2(dragData.initialPts[index].y - c2.y, dragData.initialPts[index].x - c2.x);
            const ang_new = Math.atan2(mousePos.y - c2.y, mousePos.x - c2.x);
            if (d_old > 1) {
                updateScale(dragData.initialScale * (d_new / d_old));
                p2Rotation = dragData.initialRotation + (ang_new - ang_old);
            }
            return;
        }

        if (isSSS || (targetTriangle === 1 && isAA)) return;

        let target = { ...mousePos };
        const localScale = (targetTriangle === 2 ? scaleFactor : 1);

        if (constraints.sides[prevIdx]) {
            const center = pts[prevIdx], r = fixedValues.sides[prevIdx] * localScale;
            const ang = Math.atan2(target.y - center.y, target.x - center.x);
            target.x = center.x + r * Math.cos(ang); target.y = center.y + r * Math.sin(ang);
        }
        if (constraints.sides[index]) {
            const center = pts[nextIdx], r = fixedValues.sides[index] * localScale;
            const ang = Math.atan2(target.y - center.y, target.x - center.x);
            target.x = center.x + r * Math.cos(ang); target.y = center.y + r * Math.sin(ang);
        }
        if (constraints.angles[prevIdx]) {
            const origin = pts[prevIdx], anchor = pts[nextIdx], base = Math.atan2(anchor.y - origin.y, anchor.x - origin.x);
            const tAng = base - (fixedValues.angles[prevIdx] * Math.PI / 180) * fixedValues.winding;
            const dist = getDistance(origin, target);
            target.x = origin.x + dist * Math.cos(tAng); target.y = origin.y + dist * Math.sin(tAng);
        }
        if (constraints.angles[nextIdx]) {
            const origin = pts[nextIdx], anchor = pts[prevIdx], base = Math.atan2(anchor.y - origin.y, anchor.x - origin.x);
            const tAng = base + (fixedValues.angles[nextIdx] * Math.PI / 180) * fixedValues.winding;
            const dist = getDistance(origin, target);
            target.x = origin.x + dist * Math.cos(tAng); target.y = origin.y + dist * Math.sin(tAng);
        }
        pts[index] = target;
    }

    function drawLabel(text, x, y, bgColor, textColor, isLocked) {
        ctx.font = `bold ${11 * view.zoom}px sans-serif`;
        const displayText = (isLocked ? "ðŸ”’ " : "") + text;
        const tw = ctx.measureText(displayText).width;
        ctx.fillStyle = isLocked ? "#334155" : bgColor;
        ctx.beginPath(); ctx.roundRect(x - tw/2 - 6, y - 11, tw + 12, 22, 6); ctx.fill();
        ctx.fillStyle = isLocked ? "white" : textColor;
        ctx.textAlign = "center"; ctx.fillText(displayText, x, y + 5);
    }

    function drawTriangle(pts, names, color, isSecondary) {
        const s_pts = pts.map(p => worldToScreen(p.x, p.y));
        const c_world = getCenter(pts), c_screen = worldToScreen(c_world.x, c_world.y);
        const vis = isSecondary ? visible2 : visible1;
        ctx.beginPath(); ctx.moveTo(s_pts[0].x, s_pts[0].y); ctx.lineTo(s_pts[1].x, s_pts[1].y); ctx.lineTo(s_pts[2].x, s_pts[2].y); ctx.closePath();
        ctx.strokeStyle = color; ctx.lineWidth = 3 * view.zoom; ctx.stroke();
        ctx.fillStyle = color + "10"; ctx.fill();

        if (isSecondary) {
            const handleDist = 60 * view.zoom;
            const hPos = { x: c_screen.x + Math.cos(p2Rotation - Math.PI/2) * handleDist, y: c_screen.y + Math.sin(p2Rotation - Math.PI/2) * handleDist };
            ctx.beginPath(); ctx.setLineDash([5, 5]); ctx.moveTo(c_screen.x, c_screen.y); ctx.lineTo(hPos.x, hPos.y); ctx.strokeStyle = color; ctx.stroke(); ctx.setLineDash([]);
            ctx.beginPath(); ctx.arc(hPos.x, hPos.y, 10 * view.zoom, 0, Math.PI*2); ctx.fillStyle = "white"; ctx.fill(); ctx.stroke();
            ctx.beginPath(); ctx.arc(c_screen.x, c_screen.y, 4 * view.zoom, 0, Math.PI*2); ctx.fillStyle = color; ctx.fill();
        }

        s_pts.forEach((p, i) => {
            const vertexLocked = constraints.angles[i];
            ctx.beginPath(); ctx.arc(p.x, p.y, (isSecondary ? 6 : 7) * view.zoom, 0, Math.PI*2);
            ctx.fillStyle = vertexLocked ? "#334155" : "white"; ctx.fill();
            ctx.strokeStyle = color; ctx.lineWidth = 2 * view.zoom; ctx.stroke();
            ctx.font = `bold ${fontSize * view.zoom}px sans-serif`;
            ctx.fillStyle = vertexLocked ? "#334155" : "#1e293b"; ctx.textAlign = "center";
            ctx.fillText(names[i] || "", p.x, p.y - 12 * view.zoom);

            if (vis.angles[i]) {
                const val = getAngleDegree(pts[i], pts[(i+1)%3], pts[(i+2)%3]).toFixed(1);
                const mid = { x: (p.x + (s_pts[(i+1)%3].x + s_pts[(i+2)%3].x)/2)/2, y: (p.y + (s_pts[(i+1)%3].y + s_pts[(i+2)%3].y)/2)/2 };
                const dx = mid.x - p.x, dy = mid.y - p.y, d = Math.sqrt(dx*dx + dy*dy) || 1;
                drawLabel(`${val}Â°`, p.x + (dx/d)*35*view.zoom, p.y + (dy/d)*35*view.zoom, "#fee2e2", "#ef4444", constraints.angles[i]);
            }
            if (vis.sides[i]) {
                const next = s_pts[(i+1)%3];
                const mx = (p.x + next.x)/2, my = (p.y + next.y)/2;
                const len = (getDistance(pts[i], pts[(i+1)%3]) / 20).toFixed(1);
                const dx = next.x - p.x, dy = next.y - p.y, dist = Math.sqrt(dx*dx + dy*dy) || 1;
                drawLabel(`${len}`, mx + (-dy/dist)*22*view.zoom, my + (dx/dist)*22*view.zoom, "#dcfce7", "#16a34a", constraints.sides[i]);
            }
        });
    }

    function screenToWorld(x, y) { return { x: x / view.zoom - view.x, y: y / view.zoom - view.y }; }
    function worldToScreen(x, y) { return { x: (x + view.x) * view.zoom, y: (y + view.y) * view.zoom }; }

    function draw() {
        ctx.clearRect(0, 0, width, height); ctx.strokeStyle = "#cbd5e1"; ctx.lineWidth = 0.5;
        const step = 50 * view.zoom;
        for(let x=(view.x*view.zoom)%step; x<width; x+=step) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,height); ctx.stroke(); }
        for(let y=(view.y*view.zoom)%step; y<height; y+=step) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(width,y); ctx.stroke(); }
        drawTriangle(p1, triangleNames[0], "#2563eb", false); drawTriangle(p2, triangleNames[1], "#7c3aed", true);
    }

    function updateStatus() {
        const ind = document.getElementById('statusIndicator');
        let mode = isLocked ? (Math.abs(scaleFactor - 1) < 0.001 ? "Congruent" : "Similar") : "Independent";
        let color = mode === "Congruent" ? "bg-green-500" : (mode === "Similar" ? "bg-blue-500" : "bg-orange-500");
        ind.innerHTML = `<span class="w-4 h-4 rounded-full ${color} border border-white"></span> <span class="uppercase tracking-tight text-slate-800 font-black text-[12px]">${mode}</span>`;
    }

    // Interaction Handling
    function handleStart(clientX, clientY, touches = null) {
        const rect = canvas.getBoundingClientRect();
        const worldPos = screenToWorld(clientX - rect.left, clientY - rect.top);
        updateFixedValues();
        dragData = { type: null, startTime: Date.now(), moved: false };

        if (touches && touches.length === 2) {
            dragData.type = 'pinch';
            dragData.pinchDist = Math.hypot(touches[0].clientX - touches[1].clientX, touches[0].clientY - touches[1].clientY);
            dragData.origZoom = view.zoom;
            const midX = (touches[0].clientX + touches[1].clientX) / 2;
            const midY = (touches[0].clientY + touches[1].clientY) / 2;
            dragData.mid = screenToWorld(midX - rect.left, midY - rect.top);
            return;
        }

        for(let i=0; i<3; i++) {
            if (getDistance(worldPos, p1[i]) < 30/view.zoom) {
                dragData = { type: 'p1', index: i, initialPts: JSON.parse(JSON.stringify(p1)), moved: false };
                return;
            }
        }
        for(let i=0; i<3; i++) {
            if (getDistance(worldPos, p2[i]) < 30/view.zoom) {
                dragData = { type: 'p2', index: i, initialPts: JSON.parse(JSON.stringify(p2)), initialScale: scaleFactor, initialRotation: p2Rotation, moved: false };
                return;
            }
        }
        const c2 = getCenter(p2), hPos = { x: c2.x + Math.cos(p2Rotation - Math.PI/2) * 60, y: c2.y + Math.sin(p2Rotation - Math.PI/2) * 60 };
        if (getDistance(worldPos, hPos) < 30/view.zoom) {
            dragData = { type: 'p2-rotate', initialRotation: p2Rotation, initialAngle: Math.atan2(worldPos.y - c2.y, worldPos.x - c2.x), moved: false };
            return;
        }
        if (getDistance(worldPos, c2) < 50/view.zoom) {
            dragData = { type: 'p2-move', startX: worldPos.x - c2.x, startY: worldPos.y - c2.y, moved: false };
            return;
        }
        for (let i=0; i<3; i++) {
            if (distToSegment(worldPos, p1[i], p1[(i+1)%3]) < 15/view.zoom) { dragData.type = 'toggle-side'; dragData.target = { tIdx: 0, sIdx: i }; return; }
            if (distToSegment(worldPos, p2[i], p2[(i+1)%3]) < 15/view.zoom) { dragData.type = 'toggle-side'; dragData.target = { tIdx: 1, sIdx: i }; return; }
        }
        dragData = { type: 'pan', startX: clientX, startY: clientY, origX: view.x, origY: view.y, moved: false };
    }

    function handleMove(clientX, clientY, touches = null) {
        if (!dragData.type) return;
        dragData.moved = true;
        const rect = canvas.getBoundingClientRect();
        const worldPos = screenToWorld(clientX - rect.left, clientY - rect.top);

        if (dragData.type === 'pinch' && touches && touches.length === 2) {
            const d = Math.hypot(touches[0].clientX - touches[1].clientX, touches[0].clientY - touches[1].clientY);
            const ratio = d / dragData.pinchDist;
            view.zoom = Math.max(0.1, Math.min(10, dragData.origZoom * ratio));
            const midX = (touches[0].clientX + touches[1].clientX) / 2;
            const midY = (touches[0].clientY + touches[1].clientY) / 2;
            const after = screenToWorld(midX - rect.left, midY - rect.top);
            view.x += (after.x - dragData.mid.x); view.y += (after.y - dragData.mid.y);
            draw(); return;
        }

        if (dragData.type === 'p1') { solveConstraints(dragData.index, worldPos, 1); syncTriangles(); draw(); }
        else if (dragData.type === 'p2') { 
            solveConstraints(dragData.index, worldPos, 2); 
            if (!isLocked) { const c1 = getCenter(p1), c2 = getCenter(p2); p2Offset = { x: c2.x - c1.x, y: c2.y - c1.y }; }
            draw(); 
        }
        else if (dragData.type === 'p2-rotate') { const c2 = getCenter(p2); p2Rotation = dragData.initialRotation + (Math.atan2(worldPos.y - c2.y, worldPos.x - c2.x) - dragData.initialAngle); syncTriangles(); draw(); }
        else if (dragData.type === 'p2-move') { const c2 = getCenter(p2); p2.forEach(p => { p.x += (worldPos.x - c2.x - dragData.startX); p.y += (worldPos.y - c2.y - dragData.startY); }); const c1 = getCenter(p1), curC2 = getCenter(p2); p2Offset = { x: curC2.x - c1.x, y: curC2.y - c1.y }; draw(); }
        else if (dragData.type === 'pan') { view.x = dragData.origX + (clientX - dragData.startX) / view.zoom; view.y = dragData.origY + (clientY - dragData.startY) / view.zoom; draw(); }
    }

    container.addEventListener('mousedown', e => handleStart(e.clientX, e.clientY));
    window.addEventListener('mousemove', e => handleMove(e.clientX, e.clientY));
    window.addEventListener('mouseup', () => {
        if (!dragData.moved) {
            if (dragData.type === 'p1' || dragData.type === 'p2') toggleElement(dragData.type === 'p1' ? 'v1' : 'v2', 'angle', dragData.index);
            else if (dragData.type === 'toggle-side') toggleElement(dragData.target.tIdx === 0 ? 'v1' : 'v2', 'side', dragData.target.sIdx);
        }
        dragData.type = null;
    });

    container.addEventListener('touchstart', e => { 
        if (e.target.closest('.control-panel') || e.target.closest('.fab-toggle')) return;
        e.preventDefault(); 
        handleStart(e.touches[0].clientX, e.touches[0].clientY, e.touches); 
    }, { passive: false });
    window.addEventListener('touchmove', e => { 
        if (dragData.type) { e.preventDefault(); handleMove(e.touches[0].clientX, e.touches[0].clientY, e.touches); } 
    }, { passive: false });
    window.addEventListener('touchend', () => {
        if (dragData.type && !dragData.moved) {
            if (dragData.type === 'p1' || dragData.type === 'p2') toggleElement(dragData.type === 'p1' ? 'v1' : 'v2', 'angle', dragData.index);
            else if (dragData.type === 'toggle-side') toggleElement(dragData.target.tIdx === 0 ? 'v1' : 'v2', 'side', dragData.target.sIdx);
        }
        dragData.type = null; 
    });

    container.addEventListener('wheel', e => {
        e.preventDefault(); const rect = canvas.getBoundingClientRect(); const before = screenToWorld(e.clientX - rect.left, e.clientY - rect.top);
        view.zoom = Math.max(0.1, Math.min(10, view.zoom * Math.pow(1.1, -e.deltaY / 100)));
        const after = screenToWorld(e.clientX - rect.left, e.clientY - rect.top);
        view.x += (after.x - before.x); view.y += (after.y - before.y); draw();
    }, { passive: false });

    window.addEventListener('resize', resize);
    renderControlChips(); updateFixedValues(); resize(); updateStatus();
</script>
</body>
</html>
