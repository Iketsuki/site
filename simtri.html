<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Congruent & Similar Triangles Lab</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            touch-action: none;
            overflow: hidden;
            background-color: #f1f5f9;
            font-family: system-ui, -apple-system, sans-serif;
        }
        .canvas-container {
            position: relative;
            width: 100%;
            height: 100vh;
            cursor: grab;
        }
        .canvas-container:active { cursor: grabbing; }
        
        canvas { display: block; }

        .control-panel {
            backdrop-filter: blur(20px);
            background-color: rgba(255, 255, 255, 0.92);
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 10px 0 40px rgba(0,0,0,0.08);
        }
        .hidden-panel { transform: translateX(-100%); }

        .toggle-btn {
            position: absolute;
            left: 100%;
            top: 1rem;
            background: white;
            border: 1px solid #e2e8f0;
            border-left: none;
            padding: 0.75rem 0.5rem;
            border-radius: 0 0.75rem 0.75rem 0;
            cursor: pointer;
            z-index: 50;
        }

        .section-header {
            @apply flex items-center justify-between py-2 cursor-pointer border-b border-slate-100 mb-2;
        }

        .toggle-chip {
            @apply flex-1 py-1.5 text-[9px] font-black rounded transition-all uppercase text-center cursor-pointer select-none shadow-sm active:scale-95 text-white flex items-center justify-center gap-1;
        }
        
        .toggle-chip.active { 
            background: linear-gradient(to bottom, #16a34a, #15803d);
            border: 1px solid #14532d;
        }
        
        .toggle-chip.inactive { 
            background: linear-gradient(to bottom, #ef4444, #dc2626);
            border: 1px solid #991b1b;
        }

        .bulk-btn {
            @apply text-[8px] px-1.5 py-0.5 rounded bg-slate-200 hover:bg-slate-300 text-slate-700 font-black uppercase transition-colors;
        }

        details summary::-webkit-details-marker { display: none; }
        input[type=range] { @apply accent-blue-600; }
        
        .action-btn {
            @apply px-3 py-2 bg-white border border-slate-200 rounded-lg text-[10px] font-black uppercase hover:bg-slate-50 transition-colors shadow-sm text-slate-700;
        }
        
        .name-group-input {
            @apply w-full px-3 py-1.5 bg-white border border-slate-200 rounded text-xs font-bold uppercase tracking-[0.5em] focus:ring-2 focus:ring-blue-400 focus:outline-none text-center;
        }
    </style>
</head>
<body>

<div class="canvas-container" id="container">
    <canvas id="geometryCanvas"></canvas>

    <div id="sidebar" class="control-panel fixed left-0 top-0 h-full w-72 z-40 p-5 overflow-y-auto border-r border-slate-200">
        <button onclick="toggleSidebar()" class="toggle-btn shadow-md">
            <svg id="toggleIcon" xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 text-slate-600" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />
            </svg>
        </button>

        <div class="mb-6 flex items-center justify-between">
            <h1 class="text-lg font-black tracking-tight text-slate-800">Triangle Lab</h1>
            <button onclick="resetAll()" class="text-[10px] bg-red-50 text-red-600 px-3 py-1 rounded-lg border border-red-100 font-black uppercase hover:bg-red-100 transition-colors shadow-sm">Reset</button>
        </div>

        <div class="space-y-6">
            <details class="group">
                <summary class="section-header">
                    <h2 class="text-xs font-black uppercase text-slate-400">Settings & Naming</h2>
                    <svg class="w-4 h-4 group-open:rotate-180 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path d="M19 9l-7 7-7-7"/></svg>
                </summary>
                <div class="pt-2 space-y-4">
                    <div>
                        <div class="flex justify-between items-center mb-1">
                            <h3 class="text-[10px] font-black text-slate-400 uppercase">Label Font Size</h3>
                            <span id="fontVal" class="text-xs font-black text-blue-600">14</span>
                        </div>
                        <input type="range" id="fontSlider" min="10" max="24" step="1" value="14" class="w-full" oninput="updateFontSize(this.value)">
                    </div>
                    <div class="space-y-3">
                        <div class="flex flex-col gap-1">
                            <span class="text-[9px] font-black text-blue-600 uppercase ml-1">Triangle 1</span>
                            <input type="text" id="nameTri1" maxlength="3" value="ABC" oninput="updateFullNames(0, this.value)" class="name-group-input">
                        </div>
                        <div class="flex flex-col gap-1">
                            <span class="text-[9px] font-black text-purple-600 uppercase ml-1">Triangle 2</span>
                            <input type="text" id="nameTri2" maxlength="3" value="DEF" oninput="updateFullNames(1, this.value)" class="name-group-input">
                        </div>
                    </div>
                </div>
            </details>

            <details open class="group">
                <summary class="section-header">
                    <h2 class="text-xs font-black uppercase text-slate-400">Linked Constraints</h2>
                    <svg class="w-4 h-4 group-open:rotate-180 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path d="M19 9l-7 7-7-7"/></svg>
                </summary>
                <div class="pt-2 space-y-4">
                    <div>
                        <div class="flex items-center justify-between mb-2">
                            <p class="text-[10px] font-black text-slate-500 uppercase">Lock Sides</p>
                            <div class="flex gap-1">
                                <button onclick="bulkSet('c', 'side', true)" class="bulk-btn">All</button>
                                <button onclick="bulkSet('c', 'side', false)" class="bulk-btn">None</button>
                            </div>
                        </div>
                        <div class="flex gap-2" id="c-side-container"></div>
                    </div>
                    <div>
                        <div class="flex items-center justify-between mb-2">
                            <p class="text-[10px] font-black text-slate-500 uppercase">Lock Angles</p>
                            <div class="flex gap-1">
                                <button onclick="bulkSet('c', 'angle', true)" class="bulk-btn">All</button>
                                <button onclick="bulkSet('c', 'angle', false)" class="bulk-btn">None</button>
                            </div>
                        </div>
                        <div class="flex gap-2" id="c-angle-container"></div>
                    </div>
                </div>
            </details>

            <details open class="group">
                <summary class="section-header">
                    <h2 class="text-xs font-black uppercase text-slate-400">Visual Controls</h2>
                    <svg class="w-4 h-4 group-open:rotate-180 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path d="M19 9l-7 7-7-7"/></svg>
                </summary>
                <div class="pt-2 space-y-4">
                    <!-- Triangle 1 Visuals -->
                    <div>
                        <p class="text-[9px] font-black text-blue-500 uppercase mb-2">Triangle 1 Labels</p>
                        <div class="flex gap-1 mb-2" id="v1-side-container"></div>
                        <div class="flex gap-1" id="v1-angle-container"></div>
                    </div>
                    <hr class="border-slate-100">
                    <!-- Triangle 2 Visuals -->
                    <div>
                        <p class="text-[9px] font-black text-purple-500 uppercase mb-2">Triangle 2 Labels</p>
                        <div class="flex gap-1 mb-2" id="v2-side-container"></div>
                        <div class="flex gap-1" id="v2-angle-container"></div>
                    </div>
                </div>
            </details>

            <details open class="group">
                <summary class="section-header">
                    <h2 class="text-xs font-black uppercase text-slate-400">Transformations</h2>
                    <svg class="w-4 h-4 group-open:rotate-180 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path d="M19 9l-7 7-7-7"/></svg>
                </summary>
                <div class="pt-2 space-y-4">
                    <div class="flex gap-2">
                        <button onclick="flipDEF('h')" class="action-btn flex-1">Flip H</button>
                        <button onclick="flipDEF('v')" class="action-btn flex-1">Flip V</button>
                    </div>
                    <div class="flex items-center justify-between p-3 bg-slate-100 rounded-xl">
                        <span class="text-[10px] font-black text-slate-600 uppercase">Sync Link</span>
                        <button id="lockBtn" onclick="toggleLock()" class="px-3 py-1.5 bg-green-600 text-white rounded-lg text-[10px] font-black uppercase shadow-md transition-all active:scale-95">Linked</button>
                    </div>
                    <div id="ratioControls">
                        <div class="flex justify-between items-center mb-1">
                            <h3 class="text-[10px] font-black text-slate-400 uppercase">Scale Factor</h3>
                            <span id="scaleVal" class="text-xs font-black text-blue-600">1.0</span>
                        </div>
                        <input type="range" id="scaleSlider" min="0.2" max="3.0" step="0.01" value="1" class="w-full" oninput="updateScale(this.value)">
                    </div>
                </div>
            </details>
        </div>
    </div>

    <div class="fixed top-4 left-1/2 -translate-x-1/2 bg-white/95 backdrop-blur px-6 py-2 rounded-full shadow-2xl border border-white z-10 pointer-events-none" id="statusBox">
        <div id="statusIndicator" class="text-sm font-black flex items-center gap-2"></div>
    </div>
</div>

<script>
    const canvas = document.getElementById('geometryCanvas');
    const ctx = canvas.getContext('2d');
    const container = document.getElementById('container');
    
    let width, height;
    let sidebarOpen = true;
    let view = { x: 0, y: 0, zoom: 1 };
    let isLocked = true;
    let scaleFactor = 1.0;
    let fontSize = 14;
    let p2Rotation = 0; 
    let triangleNames = [["A", "B", "C"], ["D", "E", "F"]];
    let p2Offset = { x: 400, y: 0 };

    // Independent visibility states
    let visible1 = { sides: [true, true, true], angles: [true, true, true] };
    let visible2 = { sides: [true, true, true], angles: [true, true, true] };
    let constraints = { sides: [false, false, false], angles: [false, false, false] };
    let fixedValues = { sides: [0,0,0], angles: [0,0,0], winding: 1 };

    let p1 = [{ x: 250, y: 200 }, { x: 200, y: 400 }, { x: 400, y: 400 }];
    let p2 = [{ x: 650, y: 200 }, { x: 600, y: 400 }, { x: 800, y: 400 }];

    let dragData = { type: null, index: null, startX: 0, startY: 0, initialPts: [], initialScale: 1.0, startTime: 0, moved: false };

    function resize() {
        width = container.clientWidth;
        height = container.clientHeight;
        canvas.width = width;
        canvas.height = height;
        draw();
    }

    function toggleSidebar() {
        sidebarOpen = !sidebarOpen;
        document.getElementById('sidebar').classList.toggle('hidden-panel');
        document.getElementById('toggleIcon').innerHTML = sidebarOpen ? 
            '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7" />' :
            '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7" />';
    }

    function updateFontSize(val) {
        fontSize = parseInt(val);
        document.getElementById('fontVal').innerText = fontSize;
        draw();
    }

    function updateFullNames(tIdx, val) {
        const letters = val.toUpperCase().padEnd(3, " ").split("");
        triangleNames[tIdx] = letters.slice(0, 3);
        renderControlChips();
        draw();
    }

    function toggleElement(prefix, type, index) {
        if (prefix === 'c') {
            constraints[type + 's'][index] = !constraints[type + 's'][index];
        } else if (prefix === 'v1') {
            visible1[type + 's'][index] = !visible1[type + 's'][index];
        } else if (prefix === 'v2') {
            visible2[type + 's'][index] = !visible2[type + 's'][index];
        }
        updateFixedValues();
        renderControlChips();
        draw();
    }

    function bulkSet(prefix, type, value) {
        if (prefix === 'c') {
            constraints[type + 's'] = [value, value, value];
        } else if (prefix === 'v1') {
            visible1[type + 's'] = [value, value, value];
        } else if (prefix === 'v2') {
            visible2[type + 's'] = [value, value, value];
        }
        updateFixedValues();
        renderControlChips();
        draw();
    }

    function renderControlChips() {
        const createChips = (prefix, type) => {
            const container = document.getElementById(`${prefix}-${type}-container`);
            if (!container) return;
            container.innerHTML = "";
            const targetState = prefix === 'c' ? constraints : (prefix === 'v1' ? visible1 : visible2);
            const nameIdx = prefix === 'v2' ? 1 : 0;

            for (let i = 0; i < 3; i++) {
                let label = "";
                if (type === 'side') {
                    label = triangleNames[nameIdx][i] + triangleNames[nameIdx][(i+1)%3];
                } else {
                    label = "âˆ " + triangleNames[nameIdx][i];
                }
                
                const val = targetState[type + 's'][i];
                const chip = document.createElement('div');
                chip.className = `toggle-chip ${val ? 'active' : 'inactive'}`;
                const icon = prefix === 'c' ? (val ? 'ðŸ”’' : 'ðŸ”“') : '';
                chip.innerHTML = `<span>${icon}</span> ${label}`;
                chip.onclick = () => toggleElement(prefix, type, i);
                container.appendChild(chip);
            }
        };

        createChips('c', 'side');
        createChips('c', 'angle');
        createChips('v1', 'side');
        createChips('v1', 'angle');
        createChips('v2', 'side');
        createChips('v2', 'angle');
    }

    function flipDEF(axis) {
        const c2 = getCenter(p2);
        p2 = p2.map(p => {
            if (axis === 'h') return { x: c2.x - (p.x - c2.x), y: p.y };
            return { x: p.x, y: c2.y - (p.y - c2.y) };
        });
        const c1 = getCenter(p1);
        const curC2 = getCenter(p2);
        p2Offset = { x: curC2.x - c1.x, y: curC2.y - c1.y };
        draw();
    }

    function updateFixedValues() {
        for(let i=0; i<3; i++) {
            fixedValues.sides[i] = getDistance(p1[i], p1[(i+1)%3]);
            fixedValues.angles[i] = getAngleDegree(p1[i], p1[(i+1)%3], p1[(i+2)%3]);
        }
        fixedValues.winding = Math.sign((p1[1].x - p1[0].x) * (p1[2].y - p1[0].y) - (p1[1].y - p1[0].y) * (p1[2].x - p1[0].x));
    }

    function toggleLock() {
        isLocked = !isLocked;
        const btn = document.getElementById('lockBtn');
        btn.innerText = isLocked ? "Linked" : "Independent";
        btn.className = isLocked ? "px-3 py-1.5 bg-green-600 text-white rounded-lg text-[10px] font-black uppercase shadow-md transition-all active:scale-95" : "px-3 py-1.5 bg-orange-600 text-white rounded-lg text-[10px] font-black uppercase shadow-md transition-all active:scale-95";
        if (isLocked) {
            syncTriangles();
        }
        updateStatus();
        draw();
    }

    function resetAll() {
        view = { x: 0, y: 0, zoom: 1 };
        isLocked = true;
        scaleFactor = 1.0;
        p1 = [{ x: 250, y: 200 }, { x: 200, y: 400 }, { x: 400, y: 400 }];
        p2Offset = { x: 400, y: 0 };
        p2Rotation = 0;
        triangleNames = [["A", "B", "C"], ["D", "E", "F"]];
        visible1 = { sides: [true, true, true], angles: [true, true, true] };
        visible2 = { sides: [true, true, true], angles: [true, true, true] };
        constraints = { sides: [false, false, false], angles: [false, false, false] };
        document.getElementById('nameTri1').value = "ABC";
        document.getElementById('nameTri2').value = "DEF";
        document.getElementById('scaleSlider').value = 1;
        document.getElementById('fontSlider').value = 14;
        fontSize = 14;
        renderControlChips();
        updateFixedValues();
        updateScale(1);
        draw();
    }

    function syncTriangles() {
        const c1 = getCenter(p1);
        p2 = p1.map(p => {
            let dx = (p.x - c1.x);
            let dy = (p.y - c1.y);
            let rx = dx * Math.cos(p2Rotation) - dy * Math.sin(p2Rotation);
            let ry = dx * Math.sin(p2Rotation) + dy * Math.cos(p2Rotation);
            return {
                x: rx * scaleFactor + c1.x + p2Offset.x,
                y: ry * scaleFactor + c1.y + p2Offset.y
            };
        });
    }

    function updateScale(val) {
        scaleFactor = parseFloat(val);
        document.getElementById('scaleVal').innerText = scaleFactor.toFixed(2);
        document.getElementById('scaleSlider').value = scaleFactor;
        syncTriangles(); 
        updateStatus();
        draw();
    }

    function getCenter(pts) {
        return { x: (pts[0].x + pts[1].x + pts[2].x) / 3, y: (pts[0].y + pts[1].y + pts[2].y) / 3 };
    }

    function getDistance(a, b) { return Math.sqrt((b.x-a.x)**2 + (b.y-a.y)**2); }

    function getAngleDegree(p, next, prev) {
        const a = getDistance(next, prev);
        const b = getDistance(p, prev);
        const c = getDistance(p, next);
        const cos = (b*b + c*c - a*a) / (2*b*c);
        return Math.acos(Math.max(-1, Math.min(1, cos))) * 180 / Math.PI;
    }

    function distToSegment(p, a, b) {
        const l2 = (a.x-b.x)**2 + (a.y-b.y)**2;
        if (l2 === 0) return getDistance(p, a);
        let t = ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2;
        t = Math.max(0, Math.min(1, t));
        return getDistance(p, { x: a.x + t * (b.x - a.x), y: a.y + t * (b.y - a.y) });
    }

    function solveConstraints(index, mousePos, targetTriangle) {
        if (constraints.angles[index]) return;
        const nextIdx = (index + 1) % 3;
        const prevIdx = (index + 2) % 3;
        const pts = targetTriangle === 1 ? p1 : p2;
        const lockedAnglesCount = constraints.angles.filter(v => v).length;
        const isSSS = constraints.sides.every(v => v);
        const isAA = lockedAnglesCount >= 2;

        if (targetTriangle === 2 && (isSSS || isAA)) {
            const c2 = getCenter(pts);
            const d_old = getDistance(c2, dragData.initialPts[index]);
            const d_new = getDistance(c2, mousePos);
            const ang_old = Math.atan2(dragData.initialPts[index].y - c2.y, dragData.initialPts[index].x - c2.x);
            const ang_new = Math.atan2(mousePos.y - c2.y, mousePos.x - c2.x);
            if (d_old > 1) {
                updateScale(dragData.initialScale * (d_new / d_old));
                p2Rotation = dragData.initialRotation + (ang_new - ang_old);
            }
            return;
        }

        if (isSSS || (targetTriangle === 1 && isAA)) return;

        let target = { ...mousePos };
        const localScale = (targetTriangle === 2 ? scaleFactor : 1);

        if (constraints.sides[prevIdx]) {
            const center = pts[prevIdx];
            const r = fixedValues.sides[prevIdx] * localScale;
            const ang = Math.atan2(target.y - center.y, target.x - center.x);
            target.x = center.x + r * Math.cos(ang);
            target.y = center.y + r * Math.sin(ang);
        }
        if (constraints.sides[index]) {
            const center = pts[nextIdx];
            const r = fixedValues.sides[index] * localScale;
            const ang = Math.atan2(target.y - center.y, target.x - center.x);
            target.x = center.x + r * Math.cos(ang);
            target.y = center.y + r * Math.sin(ang);
        }
        if (constraints.angles[prevIdx]) {
            const origin = pts[prevIdx], anchor = pts[nextIdx];
            const base = Math.atan2(anchor.y - origin.y, anchor.x - origin.x);
            const targetAng = base - (fixedValues.angles[prevIdx] * Math.PI / 180) * fixedValues.winding;
            const dist = getDistance(origin, target);
            target.x = origin.x + dist * Math.cos(targetAng);
            target.y = origin.y + dist * Math.sin(targetAng);
        }
        if (constraints.angles[nextIdx]) {
            const origin = pts[nextIdx], anchor = pts[prevIdx];
            const base = Math.atan2(anchor.y - origin.y, anchor.x - origin.x);
            const targetAng = base + (fixedValues.angles[nextIdx] * Math.PI / 180) * fixedValues.winding;
            const dist = getDistance(origin, target);
            target.x = origin.x + dist * Math.cos(targetAng);
            target.y = origin.y + dist * Math.sin(targetAng);
        }
        pts[index] = target;
    }

    function drawLabel(text, x, y, bgColor, textColor, isLocked) {
        ctx.font = `bold ${11 * view.zoom}px sans-serif`;
        const displayText = (isLocked ? "ðŸ”’ " : "") + text;
        const tw = ctx.measureText(displayText).width;
        ctx.fillStyle = isLocked ? "#334155" : bgColor;
        ctx.beginPath(); ctx.roundRect(x - tw/2 - 6, y - 11, tw + 12, 22, 6); ctx.fill();
        ctx.fillStyle = isLocked ? "white" : textColor;
        ctx.textAlign = "center"; ctx.fillText(displayText, x, y + 5);
    }

    function drawTriangle(pts, names, color, isSecondary) {
        const s_pts = pts.map(p => worldToScreen(p.x, p.y));
        const c_world = getCenter(pts);
        const c_screen = worldToScreen(c_world.x, c_world.y);
        const vis = isSecondary ? visible2 : visible1;

        ctx.beginPath();
        ctx.moveTo(s_pts[0].x, s_pts[0].y);
        ctx.lineTo(s_pts[1].x, s_pts[1].y);
        ctx.lineTo(s_pts[2].x, s_pts[2].y);
        ctx.closePath();
        ctx.strokeStyle = color;
        ctx.lineWidth = 3 * view.zoom;
        ctx.stroke();
        ctx.fillStyle = color + "10";
        ctx.fill();

        if (isSecondary) {
            const handleDist = 60 * view.zoom;
            const handlePos = { 
                x: c_screen.x + Math.cos(p2Rotation - Math.PI/2) * handleDist,
                y: c_screen.y + Math.sin(p2Rotation - Math.PI/2) * handleDist
            };
            ctx.beginPath(); ctx.setLineDash([5, 5]);
            ctx.moveTo(c_screen.x, c_screen.y); ctx.lineTo(handlePos.x, handlePos.y);
            ctx.strokeStyle = color; ctx.stroke(); ctx.setLineDash([]);
            ctx.beginPath(); ctx.arc(handlePos.x, handlePos.y, 10 * view.zoom, 0, Math.PI*2);
            ctx.fillStyle = "white"; ctx.fill(); ctx.stroke();
            ctx.beginPath(); ctx.arc(c_screen.x, c_screen.y, 4 * view.zoom, 0, Math.PI*2);
            ctx.fillStyle = color; ctx.fill();
        }

        s_pts.forEach((p, i) => {
            const isVertexLocked = constraints.angles[i];
            ctx.beginPath();
            ctx.arc(p.x, p.y, (isSecondary ? 6 : 7) * view.zoom, 0, Math.PI*2);
            ctx.fillStyle = isVertexLocked ? "#334155" : "white";
            ctx.fill();
            ctx.strokeStyle = color; ctx.lineWidth = 2 * view.zoom; ctx.stroke();

            ctx.font = `bold ${fontSize * view.zoom}px sans-serif`;
            ctx.fillStyle = isVertexLocked ? "#334155" : "#1e293b"; ctx.textAlign = "center";
            ctx.fillText(names[i] || "", p.x, p.y - 12 * view.zoom);

            if (vis.angles[i]) {
                const val = getAngleDegree(pts[i], pts[(i+1)%3], pts[(i+2)%3]).toFixed(1);
                const mid = { x: (p.x + (s_pts[(i+1)%3].x + s_pts[(i+2)%3].x)/2)/2, y: (p.y + (s_pts[(i+1)%3].y + s_pts[(i+2)%3].y)/2)/2 };
                const dx = mid.x - p.x, dy = mid.y - p.y, d = Math.sqrt(dx*dx + dy*dy) || 1;
                drawLabel(`${val}Â°`, p.x + (dx/d)*35*view.zoom, p.y + (dy/d)*35*view.zoom, "#fee2e2", "#ef4444", constraints.angles[i]);
            }

            if (vis.sides[i]) {
                const next = s_pts[(i+1)%3];
                const mx = (p.x + next.x)/2, my = (p.y + next.y)/2;
                const len = (getDistance(pts[i], pts[(i+1)%3]) / 20).toFixed(1);
                const dx = next.x - p.x, dy = next.y - p.y, dist = Math.sqrt(dx*dx + dy*dy) || 1;
                drawLabel(`${len}`, mx + (-dy/dist)*22*view.zoom, my + (dx/dist)*22*view.zoom, "#dcfce7", "#16a34a", constraints.sides[i]);
            }
        });
    }

    function screenToWorld(x, y) { return { x: x / view.zoom - view.x, y: y / view.zoom - view.y }; }
    function worldToScreen(x, y) { return { x: (x + view.x) * view.zoom, y: (y + view.y) * view.zoom }; }

    function draw() {
        ctx.clearRect(0, 0, width, height);
        ctx.strokeStyle = "#cbd5e1"; ctx.lineWidth = 0.5;
        const step = 50 * view.zoom;
        for(let x=(view.x*view.zoom)%step; x<width; x+=step) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,height); ctx.stroke(); }
        for(let y=(view.y*view.zoom)%step; y<height; y+=step) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(width,y); ctx.stroke(); }
        drawTriangle(p1, triangleNames[0], "#2563eb", false);
        drawTriangle(p2, triangleNames[1], "#7c3aed", true);
    }

    function updateStatus() {
        const ind = document.getElementById('statusIndicator');
        let mode = "Independent", color = "bg-orange-500";
        if (isLocked) {
            if (Math.abs(scaleFactor - 1) < 0.001) { mode = "Congruent"; color = "bg-green-500"; }
            else { mode = "Similar"; color = "bg-blue-500"; }
        }
        ind.innerHTML = `<span class="w-4 h-4 rounded-full ${color} shadow-sm border border-white"></span> <span class="uppercase tracking-tight text-slate-800 font-black text-[12px]">${mode}</span>`;
    }

    container.addEventListener('mousedown', (e) => {
        const rect = canvas.getBoundingClientRect();
        const worldPos = screenToWorld(e.clientX - rect.left, e.clientY - rect.top);
        updateFixedValues();
        dragData = { type: null, startTime: Date.now(), moved: false };

        // Check P1 Points
        for(let i=0; i<3; i++) {
            if (getDistance(worldPos, p1[i]) < 20/view.zoom) {
                dragData = { type: 'p1', index: i, initialPts: JSON.parse(JSON.stringify(p1)), moved: false };
                return;
            }
        }
        // Check P2 Points
        for(let i=0; i<3; i++) {
            if (getDistance(worldPos, p2[i]) < 20/view.zoom) {
                dragData = { type: 'p2', index: i, initialPts: JSON.parse(JSON.stringify(p2)), initialScale: scaleFactor, initialRotation: p2Rotation, moved: false };
                return;
            }
        }
        // Handle rotation check
        const c2 = getCenter(p2);
        const hPos = { x: c2.x + Math.cos(p2Rotation - Math.PI/2) * 60, y: c2.y + Math.sin(p2Rotation - Math.PI/2) * 60 };
        if (getDistance(worldPos, hPos) < 20/view.zoom) {
            dragData = { type: 'p2-rotate', initialRotation: p2Rotation, initialAngle: Math.atan2(worldPos.y - c2.y, worldPos.x - c2.x), moved: false };
            return;
        }
        // Move check
        if (getDistance(worldPos, c2) < 40/view.zoom) {
            dragData = { type: 'p2-move', startX: worldPos.x - c2.x, startY: worldPos.y - c2.y, moved: false };
            return;
        }
        // Side toggles check
        for (let i=0; i<3; i++) {
            if (distToSegment(worldPos, p1[i], p1[(i+1)%3]) < 10/view.zoom) { dragData.type = 'toggle-side'; dragData.target = { tIdx: 0, sIdx: i }; return; }
            if (distToSegment(worldPos, p2[i], p2[(i+1)%3]) < 10/view.zoom) { dragData.type = 'toggle-side'; dragData.target = { tIdx: 1, sIdx: i }; return; }
        }
        
        if (e.button === 2 || e.altKey) {
            dragData = { type: 'pan', startX: e.clientX, startY: e.clientY, origX: view.x, origY: view.y, moved: false };
        }
    });

    window.addEventListener('mousemove', (e) => {
        const rect = canvas.getBoundingClientRect();
        const worldPos = screenToWorld(e.clientX - rect.left, e.clientY - rect.top);
        if (!dragData.type) return;
        dragData.moved = true;

        if (dragData.type === 'p1') {
            solveConstraints(dragData.index, worldPos, 1);
            syncTriangles(); draw();
        } else if (dragData.type === 'p2') {
            solveConstraints(dragData.index, worldPos, 2);
            if (!isLocked) {
                const c1 = getCenter(p1), c2 = getCenter(p2);
                p2Offset = { x: c2.x - c1.x, y: c2.y - c1.y };
            }
            draw();
        } else if (dragData.type === 'p2-rotate') {
            const c2 = getCenter(p2);
            p2Rotation = dragData.initialRotation + (Math.atan2(worldPos.y - c2.y, worldPos.x - c2.x) - dragData.initialAngle);
            syncTriangles(); draw();
        } else if (dragData.type === 'p2-move') {
            const c2 = getCenter(p2);
            p2.forEach(p => { p.x += (worldPos.x - c2.x - dragData.startX); p.y += (worldPos.y - c2.y - dragData.startY); });
            const c1 = getCenter(p1), curC2 = getCenter(p2);
            p2Offset = { x: curC2.x - c1.x, y: curC2.y - c1.y };
            draw();
        } else if (dragData.type === 'pan') {
            view.x = dragData.origX + (e.clientX - dragData.startX) / view.zoom;
            view.y = dragData.origY + (e.clientY - dragData.startY) / view.zoom;
            draw();
        }
    });

    window.addEventListener('mouseup', () => {
        // Toggle logic: If we haven't moved much and it's a short click
        if (!dragData.moved) {
            if (dragData.type === 'p1' || dragData.type === 'p2') {
                toggleElement(dragData.type === 'p1' ? 'v1' : 'v2', 'angle', dragData.index);
            } else if (dragData.type === 'toggle-side') {
                toggleElement(dragData.target.tIdx === 0 ? 'v1' : 'v2', 'side', dragData.target.sIdx);
            }
        }
        dragData.type = null;
    });

    container.addEventListener('wheel', (e) => {
        e.preventDefault();
        const rect = canvas.getBoundingClientRect();
        const mouseX = e.clientX - rect.left, mouseY = e.clientY - rect.top;
        const before = screenToWorld(mouseX, mouseY);
        view.zoom = Math.max(0.1, Math.min(10, view.zoom * Math.pow(1.1, -e.deltaY / 100)));
        const after = screenToWorld(mouseX, mouseY);
        view.x += (after.x - before.x); view.y += (after.y - before.y);
        draw();
    }, { passive: false });

    window.addEventListener('contextmenu', e => e.preventDefault());
    window.addEventListener('resize', resize);
    renderControlChips(); updateFixedValues(); resize(); updateStatus();
</script>

</body>
</html>
