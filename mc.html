<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MCQ Maker - Word & Spreadsheet Export</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
            color: #1e293b;
        }

        .tnr { font-family: "Times New Roman", Times, serif; }
        .courier { font-family: "Courier New", Courier, monospace; white-space: pre-wrap; }

        .editable:focus {
            outline: 2px solid #3b82f6;
            background: white;
            border-radius: 4px;
            padding: 2px;
        }

        .preview-scroll {
            max-height: 75vh;
            overflow-y: auto;
            border: 1px solid #e2e8f0;
            padding: 2rem;
            background: #f1f5f9;
        }

        .copy-toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #1e293b;
            color: white;
            padding: 12px 24px;
            border-radius: 99px;
            z-index: 100;
            display: none;
            animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp { from { bottom: 0; opacity: 0; } to { bottom: 20px; opacity: 1; } }
        
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #f1f1f1; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
    </style>
</head>
<body class="p-4 md:p-8">
    <div id="toast" class="copy-toast">Copied to clipboard!</div>
    
    <div class="max-w-5xl mx-auto">
        <header class="mb-8 flex flex-col md:flex-row justify-between items-start md:items-center gap-4">
            <div>
                <h1 class="text-3xl font-bold text-slate-800">MCQ Table Maker</h1>
                <div class="flex items-center gap-4 mt-1">
                    <p class="text-slate-500 text-sm">Undo: Ctrl+Z | Redo: Ctrl+Y</p>
                    <div class="flex gap-2">
                        <button onclick="undo()" id="undoBtn" class="text-xs bg-white border px-2 py-1 rounded opacity-50 cursor-not-allowed">Undo</button>
                        <button onclick="redo()" id="redoBtn" class="text-xs bg-white border px-2 py-1 rounded opacity-50 cursor-not-allowed">Redo</button>
                    </div>
                </div>
            </div>
            <div class="flex flex-wrap gap-2">
                <input type="file" id="csvFileInput" accept=".csv" class="hidden" onchange="importCSV(event)">
                <button onclick="document.getElementById('csvFileInput').click()" class="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-lg font-semibold transition">Import CSV</button>
                <button onclick="exportCSV()" class="bg-emerald-600 hover:bg-emerald-700 text-white px-4 py-2 rounded-lg font-semibold transition">Export CSV</button>
                <button onclick="smartPasteAll()" class="bg-amber-500 hover:bg-amber-600 text-white px-4 py-2 rounded-lg font-semibold transition">‚ö° Smart Paste All</button>
                <button onclick="addQuestion()" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg font-semibold transition">+ Add Question</button>
                <button onclick="toggleExportMode()" class="bg-slate-800 hover:bg-slate-900 text-white px-4 py-2 rounded-lg font-semibold transition">Full Preview</button>
            </div>
        </header>

        <div id="questionsContainer" class="space-y-8 mb-12"></div>

        <!-- Bottom Actions -->
        <div class="border-t pt-8 pb-16 flex flex-wrap justify-center gap-4">
             <button onclick="addQuestion()" class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-xl font-bold shadow-lg transition transform hover:-translate-y-1">
                + Add Another Question
             </button>
             <button onclick="smartPasteAll()" class="bg-amber-500 hover:bg-amber-600 text-white px-6 py-3 rounded-xl font-bold shadow-lg transition transform hover:-translate-y-1">
                ‚ö° Paste from Clipboard
             </button>
             <button onclick="toggleExportMode()" class="bg-slate-800 hover:bg-slate-900 text-white px-6 py-3 rounded-xl font-bold shadow-lg transition transform hover:-translate-y-1">
                Preview & Export All
             </button>
        </div>

        <!-- Export Modal -->
        <div id="exportModal" class="hidden fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4">
            <div class="bg-white rounded-xl max-w-5xl w-full max-h-[90vh] overflow-hidden flex flex-col shadow-2xl">
                <div class="flex justify-between items-center p-6 border-b">
                    <div>
                        <h2 class="text-xl font-bold">Word Export Preview</h2>
                        <p class="text-xs text-slate-500">Scroll to review. Copy all tables to paste into Microsoft Word.</p>
                    </div>
                    <div class="flex gap-2">
                        <button onclick="copyAllTables()" class="bg-blue-600 text-white px-6 py-2 rounded-lg font-semibold hover:bg-blue-700">Copy All for Word</button>
                        <button onclick="toggleExportMode()" class="bg-slate-100 px-4 py-2 rounded-lg hover:bg-slate-200">Close</button>
                    </div>
                </div>
                <div class="preview-scroll p-4 md:p-12">
                    <div id="exportArea" class="bg-white shadow-sm mx-auto" style="max-width: 8.5in;"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden element for single question copying -->
    <div id="singleCopyBuffer" style="position: absolute; left: -9999px;"></div>

    <script>
        let questions = [];
        let history = [];
        let historyIndex = -1;

        // --- History Management ---
        function saveState() {
            const currentState = JSON.stringify(questions);
            if (historyIndex >= 0 && currentState === history[historyIndex]) return;
            if (historyIndex < history.length - 1) history = history.slice(0, historyIndex + 1);
            history.push(currentState);
            if (history.length > 50) history.shift();
            historyIndex = history.length - 1;
            updateHistoryButtons();
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                questions = JSON.parse(history[historyIndex]);
                renderQuestions(false);
                updateHistoryButtons();
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                questions = JSON.parse(history[historyIndex]);
                renderQuestions(false);
                updateHistoryButtons();
            }
        }

        function updateHistoryButtons() {
            const u = document.getElementById('undoBtn');
            const r = document.getElementById('redoBtn');
            u.disabled = historyIndex <= 0;
            r.disabled = historyIndex >= history.length - 1;
            u.style.opacity = u.disabled ? "0.3" : "1";
            r.style.opacity = r.disabled ? "0.3" : "1";
        }

        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'z') { e.preventDefault(); undo(); }
                if (e.key === 'y') { e.preventDefault(); redo(); }
            }
        });

        // --- Core Rendering ---
        function renderQuestions(shouldSave = true) {
            if (shouldSave) saveState();
            const container = document.getElementById('questionsContainer');
            container.innerHTML = '';

            questions.forEach((q, qIdx) => {
                const card = document.createElement('div');
                card.className = 'bg-white border rounded-xl shadow-sm overflow-hidden transition-all hover:shadow-md';
                card.innerHTML = `
                    <div class="bg-slate-50 px-4 py-2 border-b flex justify-between items-center">
                        <div class="flex items-center gap-3">
                            <span class="font-bold text-slate-600 uppercase text-[10px] tracking-widest">Question ${qIdx + 1}</span>
                            <button onclick="copyQuestionTable(${qIdx})" class="text-[10px] bg-white border border-blue-200 text-blue-600 px-2 py-0.5 rounded-md hover:bg-blue-50 transition">Copy Word Table</button>
                        </div>
                        <div class="flex gap-2">
                            <button onclick="moveUp(${qIdx})" class="text-slate-400 hover:text-slate-600">‚Üë</button>
                            <button onclick="moveDown(${qIdx})" class="text-slate-400 hover:text-slate-600">‚Üì</button>
                            <button onclick="deleteQuestion(${qIdx})" class="text-red-400 hover:text-red-600 ml-2">‚úï</button>
                        </div>
                    </div>
                    <div class="p-6 space-y-4">
                        <div class="flex gap-4">
                            <div class="w-12 text-center pt-1"><div class="tnr text-lg font-bold text-blue-600">${qIdx + 1}.</div></div>
                            <div class="flex-1">
                                <div contenteditable="true" class="editable tnr text-lg outline-none" onblur="updateQuestionText(${qIdx}, this.innerText)">${q.text}</div>
                            </div>
                        </div>

                        <div class="space-y-3">
                            <div class="space-y-2">${q.blocks.map((block, bIdx) => renderBlock(qIdx, bIdx, block)).join('')}</div>
                            <div class="flex flex-wrap items-center gap-2 pt-2">
                                <button onclick="addBlock(${qIdx}, 'text')" class="text-[10px] bg-slate-100 px-3 py-1 rounded-full hover:bg-slate-200 transition">+ Text</button>
                                <button onclick="addBlock(${qIdx}, 'list')" class="text-[10px] bg-slate-100 px-3 py-1 rounded-full hover:bg-slate-200 transition">+ List</button>
                                <button onclick="addBlock(${qIdx}, 'code')" class="text-[10px] bg-slate-100 px-3 py-1 rounded-full hover:bg-slate-200 transition">+ Code</button>
                                <div class="w-[1px] h-4 bg-slate-200 mx-2"></div>
                                <button onclick="smartPasteList(${qIdx})" class="text-[10px] bg-indigo-50 text-indigo-600 px-3 py-1 rounded-full hover:bg-indigo-100 transition">üìã Paste List</button>
                                <button onclick="smartPasteCode(${qIdx})" class="text-[10px] bg-blue-50 text-blue-600 px-3 py-1 rounded-full hover:bg-blue-100 transition">üìã Paste Code</button>
                                <button onclick="smartPasteAnswer(${qIdx})" class="text-[10px] bg-emerald-50 text-emerald-600 px-3 py-1 rounded-full hover:bg-emerald-100 transition">‚úÖ Paste Answer</button>
                            </div>
                        </div>

                        <div class="pt-6 border-t mt-4">
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-x-12 gap-y-4">
                                ${q.options.map((opt, oIdx) => `
                                    <div class="flex items-start gap-3 p-2 rounded-lg group ${q.answer === oIdx ? 'bg-blue-50/50 ring-1 ring-blue-100' : ''}">
                                        <div class="flex flex-col items-center">
                                            <button onclick="setAnswer(${qIdx}, ${oIdx})" class="tnr w-7 h-7 flex items-center justify-center rounded-lg font-bold shadow-sm transition ${q.answer === oIdx ? 'bg-blue-600 text-white' : 'bg-white text-slate-500 hover:bg-blue-100 border'}">${opt.label}</button>
                                            <div class="flex opacity-0 group-hover:opacity-100 transition mt-2">
                                                <button onclick="moveOption(${qIdx}, ${oIdx}, -1)" class="text-[10px] px-1 text-slate-400 hover:text-blue-600">‚Üë</button>
                                                <button onclick="moveOption(${qIdx}, ${oIdx}, 1)" class="text-[10px] px-1 text-slate-400 hover:text-blue-600">‚Üì</button>
                                            </div>
                                        </div>
                                        <div class="flex-1">
                                            <div contenteditable="true" class="editable tnr outline-none min-h-[1.5rem] ${opt.isCode ? 'courier bg-slate-50 p-2 rounded' : ''} ${q.answer === oIdx ? 'underline decoration-blue-400 underline-offset-4 font-semibold' : ''}" onblur="updateOptionText(${qIdx}, ${oIdx}, this.innerText)">${opt.text}</div>
                                            <button onclick="toggleOptionStyle(${qIdx}, ${oIdx})" class="text-[8px] text-slate-300 uppercase font-bold hover:text-blue-500 mt-1 block tracking-tighter">Toggle Mono</button>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;
                container.appendChild(card);
            });
        }

        function renderBlock(qIdx, bIdx, block) {
            const indent = block.indent || 1;
            const indentPx = indent * 28; 
            let content = '';
            
            if (block.type === 'text') {
                content = `<div contenteditable="true" class="editable tnr text-md outline-none py-1 border-b border-dashed border-slate-100 focus:border-blue-200" style="margin-left: ${indentPx}px" onblur="updateBlockContent(${qIdx}, ${bIdx}, this.innerText)">${block.content}</div>`;
            } else if (block.type === 'code') {
                content = `<div contenteditable="true" class="editable courier bg-slate-50 text-slate-700 p-3 rounded-lg border border-slate-200 text-sm shadow-inner" style="margin-left: ${indentPx}px" onblur="updateBlockContent(${qIdx}, ${bIdx}, this.innerText)">${block.content}</div>`;
            } else if (block.type === 'list') {
                content = `
                    <div class="space-y-2" style="margin-left: ${indentPx}px">
                        ${block.items.map((item, iIdx) => `
                            <div class="flex gap-2 items-start group/item">
                                <div class="flex flex-col pt-1 opacity-0 group-hover/item:opacity-100 transition">
                                    <button onclick="moveListItem(${qIdx}, ${bIdx}, ${iIdx}, -1)" class="text-[8px] text-slate-400 hover:text-blue-600">‚ñ≤</button>
                                    <button onclick="moveListItem(${qIdx}, ${bIdx}, ${iIdx}, 1)" class="text-[8px] text-slate-400 hover:text-blue-600">‚ñº</button>
                                </div>
                                <div contenteditable="true" class="tnr w-10 text-slate-400 font-bold outline-none focus:text-blue-600" onblur="updateListItemLabel(${qIdx}, ${bIdx}, ${iIdx}, this.innerText)">${item.label}</div>
                                <div contenteditable="true" class="tnr flex-1 outline-none min-h-[1.2rem]" onblur="updateListItemText(${qIdx}, ${bIdx}, ${iIdx}, this.innerText)">${item.text}</div>
                                <button onclick="removeListItem(${qIdx}, ${bIdx}, ${iIdx})" class="opacity-0 group-hover/item:opacity-100 text-red-300 hover:text-red-500 transition">‚úï</button>
                            </div>
                        `).join('')}
                        <button onclick="addListItem(${qIdx}, ${bIdx})" class="text-[9px] font-bold text-blue-400 hover:text-blue-600 ml-12 uppercase tracking-tight">+ New Item</button>
                    </div>`;
            }

            return `
                <div class="relative group border border-transparent hover:border-blue-50 p-2 rounded-xl transition-colors">
                    <div class="flex justify-between items-center mb-2">
                        <div class="flex items-center gap-3">
                            <span class="text-[8px] font-black text-slate-300 uppercase tracking-widest">${block.type}</span>
                            <div class="flex items-center gap-1 opacity-0 group-hover:opacity-100 transition">
                                <button onclick="adjustIndent(${qIdx}, ${bIdx}, -1)" class="w-6 h-6 flex items-center justify-center bg-white border shadow-sm rounded-md text-[10px] hover:bg-slate-50">‚Üê</button>
                                <button onclick="adjustIndent(${qIdx}, ${bIdx}, 1)" class="w-6 h-6 flex items-center justify-center bg-white border shadow-sm rounded-md text-[10px] hover:bg-slate-50">‚Üí</button>
                                <div class="w-[1px] h-3 bg-slate-200 mx-1"></div>
                                <button onclick="moveBlock(${qIdx}, ${bIdx}, -1)" class="w-6 h-6 flex items-center justify-center bg-white border shadow-sm rounded-md text-[10px] hover:bg-slate-50">‚Üë</button>
                                <button onclick="moveBlock(${qIdx}, ${bIdx}, 1)" class="w-6 h-6 flex items-center justify-center bg-white border shadow-sm rounded-md text-[10px] hover:bg-slate-50">‚Üì</button>
                            </div>
                        </div>
                        <button onclick="deleteBlock(${qIdx}, ${bIdx})" class="opacity-0 group-hover:opacity-100 text-red-300 hover:text-red-500 transition">‚úï</button>
                    </div>
                    ${content}
                </div>
            `;
        }

        // --- Data Handling ---
        function updateQuestionText(qIdx, text) { if (questions[qIdx].text !== text) { questions[qIdx].text = text; saveState(); } }
        function updateOptionText(qIdx, oIdx, text) { if (questions[qIdx].options[oIdx].text !== text) { questions[qIdx].options[oIdx].text = text; saveState(); } }
        function updateBlockContent(qIdx, bIdx, text) { if (questions[qIdx].blocks[bIdx].content !== text) { questions[qIdx].blocks[bIdx].content = text; saveState(); } }
        function updateListItemLabel(qIdx, bIdx, iIdx, text) { questions[qIdx].blocks[bIdx].items[iIdx].label = text; saveState(); }
        function updateListItemText(qIdx, bIdx, iIdx, text) { questions[qIdx].blocks[bIdx].items[iIdx].text = text; saveState(); }

        function moveUp(i) { if(i>0) { [questions[i], questions[i-1]] = [questions[i-1], questions[i]]; renderQuestions(); } }
        function moveDown(i) { if(i<questions.length-1) { [questions[i], questions[i+1]] = [questions[i+1], questions[i]]; renderQuestions(); } }
        function deleteQuestion(i) { questions.splice(i, 1); renderQuestions(); }
        function setAnswer(qIdx, oIdx) { questions[qIdx].answer = questions[qIdx].answer === oIdx ? null : oIdx; renderQuestions(); }
        function adjustIndent(qIdx, bIdx, dir) { questions[qIdx].blocks[bIdx].indent = Math.max(0, Math.min(6, (questions[qIdx].blocks[bIdx].indent || 0) + dir)); renderQuestions(); }
        
        function moveBlock(qIdx, bIdx, dir) {
            const blocks = questions[qIdx].blocks;
            const target = bIdx + dir;
            if (target >= 0 && target < blocks.length) {
                [blocks[bIdx], blocks[target]] = [blocks[target], blocks[bIdx]];
                renderQuestions();
            }
        }

        function toggleOptionStyle(qIdx, oIdx) {
            questions[qIdx].options[oIdx].isCode = !questions[qIdx].options[oIdx].isCode;
            renderQuestions();
        }

        function addQuestion() {
            questions.push({
                text: "Question Title...",
                blocks: [],
                options: [{label:"A.",text:""},{label:"B.",text:""},{label:"C.",text:""},{label:"D.",text:""}],
                answer: null
            });
            renderQuestions();
            window.scrollTo({ top: document.body.scrollHeight, behavior: 'smooth' });
        }

        function addBlock(qIdx, type) {
            const b = { type, indent: 1 };
            if (type === 'list') b.items = [{ label: "(1)", text: "" }];
            else b.content = "";
            questions[qIdx].blocks.push(b);
            renderQuestions();
        }

        function addListItem(qIdx, bIdx) {
            const items = questions[qIdx].blocks[bIdx].items;
            const nextIdx = items.length + 1;
            items.push({ label: `(${nextIdx})`, text: "" });
            renderQuestions();
        }

        function removeListItem(qIdx, bIdx, iIdx) {
            questions[qIdx].blocks[bIdx].items.splice(iIdx, 1);
            renderQuestions();
        }

        // --- Export & Copy Logic ---
        function generateHTMLForQuestion(q, idx) {
            let html = `<table class="tnr" style="border-collapse: collapse; width: 100%; font-size: 11pt; color: black; background: white; margin-bottom: 20px;">`;
            html += `<tr><td style="width:40pt; border: 1px solid white; font-weight: bold; vertical-align: top;">${idx + 1}.</td><td colspan="2" style="border: 1px solid white; vertical-align: top;">${q.text}</td></tr>`;
            
            q.blocks.forEach(block => {
                const bIndent = (block.indent || 0) * 18;
                if (block.type === 'list') {
                    block.items.forEach(it => {
                        html += `<tr><td style="border:1px solid white;"></td><td style="width:40pt; border:1px solid white; padding-left:${bIndent}pt; color: #444; vertical-align: top;">${it.label}</td><td style="border:1px solid white; vertical-align: top;">${it.text}</td></tr>`;
                    });
                } else {
                    const font = block.type === 'code' ? "font-family: 'Courier New', Courier, monospace; font-size: 10pt; background-color: #f8f8f8;" : "";
                    html += `<tr><td style="border:1px solid white;"></td><td colspan="2" style="border:1px solid white; padding-left:${bIndent}pt; ${font} vertical-align: top;">${block.content}</td></tr>`;
                }
            });

            q.options.forEach((opt, oIdx) => {
                const decoration = q.answer === oIdx ? "text-decoration: underline; font-weight: bold;" : "";
                const font = opt.isCode ? "font-family: 'Courier New', Courier, monospace; font-size: 10pt;" : "";
                html += `<tr><td style="border:1px solid white;"></td><td style="width:40pt; border:1px solid white; font-weight: bold; vertical-align: top;">${opt.label}</td><td style="border:1px solid white; ${decoration} ${font} vertical-align: top;">${opt.text}</td></tr>`;
            });

            html += `</table>`;
            return html;
        }

        function copyQuestionTable(qIdx) {
            const buffer = document.getElementById('singleCopyBuffer');
            buffer.innerHTML = generateHTMLForQuestion(questions[qIdx], qIdx);
            
            const range = document.createRange();
            range.selectNode(buffer);
            window.getSelection().removeAllRanges();
            window.getSelection().addRange(range);
            document.execCommand('copy');
            window.getSelection().removeAllRanges();
            showToast();
        }

        function copyAllTables() {
            const area = document.getElementById('exportArea');
            const range = document.createRange();
            range.selectNode(area);
            window.getSelection().removeAllRanges();
            window.getSelection().addRange(range);
            document.execCommand('copy');
            window.getSelection().removeAllRanges();
            showToast("All formatting copied!");
        }

        function toggleExportMode() {
            const m = document.getElementById('exportModal');
            if (m.classList.contains('hidden')) {
                document.getElementById('exportArea').innerHTML = questions.map((q, i) => generateHTMLForQuestion(q, i)).join('');
                m.classList.remove('hidden');
            } else m.classList.add('hidden');
        }

        function showToast(msg = "Question table copied!") {
            const t = document.getElementById('toast');
            t.innerText = msg;
            t.style.display = 'block';
            setTimeout(() => { t.style.display = 'none'; }, 2000);
        }

        // --- CSV Import/Export ---
        function exportCSV() {
            let csv = "\uFEFF[#Index],Content,Label,Details\n";
            questions.forEach((q, idx) => {
                csv += `"${idx + 1}","${q.text.replace(/"/g, '""')}","",""\n`;
                q.blocks.forEach(b => {
                    if (b.type === 'list') b.items.forEach(it => csv += `,"List Item","${it.label}","${it.text.replace(/"/g, '""')}"\n`);
                    else csv += `,"${b.type === 'code' ? 'Code' : 'Text'}","","${b.content.replace(/"/g, '""')}"\n`;
                });
                q.options.forEach(o => csv += `,"Option","${o.label}","${o.text.replace(/"/g, '""')}"\n`);
            });
            const blob = new Blob([csv], { type: 'text/csv' });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = `mcqs_${new Date().toISOString().slice(0,10)}.csv`;
            link.click();
        }

        function parseCSVLines(text) {
            const lines = [];
            let currentLine = [];
            let currentField = '';
            let inQuotes = false;
            
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const nextChar = text[i+1];
                
                if (char === '"' && inQuotes && nextChar === '"') {
                    currentField += '"';
                    i++;
                } else if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    currentLine.push(currentField.trim());
                    currentField = '';
                } else if ((char === '\r' || char === '\n') && !inQuotes) {
                    currentLine.push(currentField.trim());
                    if (currentLine.some(f => f !== '')) lines.push(currentLine);
                    currentLine = [];
                    currentField = '';
                    if (char === '\r' && nextChar === '\n') i++;
                } else {
                    currentField += char;
                }
            }
            if (currentField || currentLine.length > 0) {
                currentLine.push(currentField.trim());
                lines.push(currentLine);
            }
            return lines;
        }

        function importCSV(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                const allLines = parseCSVLines(e.target.result);
                const newQs = [];
                let currentQ = null;

                allLines.forEach((clean, i) => {
                    if (i === 0) return; // Header
                    
                    const indexCol = clean[0];
                    const contentCol = clean[1];
                    const labelCol = clean[2];
                    const detailsCol = clean[3];

                    // New Question starts if index is a number
                    if (indexCol && /^\d+/.test(indexCol)) {
                        if (currentQ) newQs.push(currentQ);
                        currentQ = { text: contentCol || "", blocks: [], options: [], answer: null };
                    } 
                    else if (currentQ) {
                        if (contentCol === "Option") {
                            currentQ.options.push({ label: labelCol, text: detailsCol, isCode: false });
                        } else if (contentCol === "List Item") {
                            let last = currentQ.blocks[currentQ.blocks.length - 1];
                            if (!last || last.type !== 'list') currentQ.blocks.push(last = { type: 'list', items: [], indent: 1 });
                            last.items.push({ label: labelCol, text: detailsCol });
                        } else if (contentCol === "Code" || contentCol === "Text") {
                            currentQ.blocks.push({ type: contentCol.toLowerCase(), content: detailsCol, indent: 1 });
                        }
                    }
                });
                if (currentQ) newQs.push(currentQ);
                if (newQs.length) {
                    questions = newQs;
                    renderQuestions();
                }
            };
            reader.readAsText(file);
        }

        // --- Clipboard Import Logic ---

        async function smartPasteAnswer(qIdx) {
            try {
                const text = await navigator.clipboard.readText();
                if (!text) return;
                // Look for patterns like "Ans: A", "Answer: B", "A", "[A]"
                const match = text.match(/(?:Ans|Answer|Key)?[:\s]*\[?([A-D])\]?/i);
                if (match) {
                    const ansLetter = match[1].toUpperCase();
                    const index = ansLetter.charCodeAt(0) - 65;
                    questions[qIdx].answer = index;
                    renderQuestions();
                    showToast(`Answer set to ${ansLetter}`);
                }
            } catch (err) { console.error(err); }
        }

        async function smartPasteList(qIdx) {
            try {
                const text = await navigator.clipboard.readText();
                if (!text) return;
                const lines = text.split(/\r?\n/).map(l => l.trim()).filter(l => l.length > 0);
                const listItems = [];
                lines.forEach(line => {
                    const match = line.match(/^[\(\[]?(\d+)[\)\]\.\s]+(.*)/);
                    if (match) listItems.push({ label: `(${match[1]})`, text: match[2] });
                    else if (listItems.length > 0) listItems[listItems.length-1].text += " " + line;
                });
                if (listItems.length) {
                    questions[qIdx].blocks.push({ type: 'list', items: listItems, indent: 1 });
                    renderQuestions();
                }
            } catch (e) { console.error(e); }
        }

        async function smartPasteCode(qIdx) {
            try {
                const text = await navigator.clipboard.readText();
                if (text) {
                    questions[qIdx].blocks.push({ type: 'code', content: text, indent: 1 });
                    renderQuestions();
                }
            } catch (e) { console.error(e); }
        }

        async function smartPasteAll() {
            try {
                const text = await navigator.clipboard.readText();
                if (!text) return;
                const chunks = text.split(/\[Q\]:/g).filter(c => c.trim().length > 0);
                const results = [];
                chunks.forEach(chunk => {
                    const lines = chunk.split(/\r?\n/).map(l => l.trim()).filter(l => l.length > 0);
                    const qObj = { text: "", blocks: [], options: [{label:"A.",text:""},{label:"B.",text:""},{label:"C.",text:""},{label:"D.",text:""}], answer: null };
                    let curQText = [], parsingOpt = false;
                    lines.forEach(line => {
                        const optMatch = line.match(/^\[?([A-D])\]?[\.\s:]+(.*)/i);
                        const listMatch = line.match(/^[\(\[]?(\d+)[\)\]\.\s]+(.*)/);
                        if (optMatch) {
                            qObj.options[optMatch[1].toUpperCase().charCodeAt(0)-65].text = optMatch[2];
                            parsingOpt = true;
                        } else if (listMatch && !parsingOpt) {
                            let last = qObj.blocks[qObj.blocks.length - 1];
                            if (!last || last.type !== 'list') qObj.blocks.push(last = { type: 'list', items: [], indent: 1 });
                            last.items.push({ label: `(${listMatch[1]})`, text: listMatch[2] });
                        } else if (!parsingOpt) curQText.push(line);
                        else {
                            const lastIdx = qObj.options.findLastIndex(o => o.text);
                            if (lastIdx !== -1) qObj.options[lastIdx].text += " " + line;
                        }
                    });
                    qObj.text = curQText.join(" ");
                    results.push(qObj);
                });
                if (results.length) { questions = [...questions, ...results]; renderQuestions(); }
            } catch (e) { console.error(e); }
        }

        // Initial render
        addQuestion();
    </script>
</body>
</html>
