<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MCQ Maker - Pro Edition</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f8fafc;
            color: #1e293b;
            scroll-behavior: smooth;
        }

        .tnr { font-family: "Times New Roman", Times, serif; }
        .courier { font-family: "Courier New", Courier, monospace; white-space: pre-wrap; }

        .editable:focus {
            outline: 2px solid #3b82f6;
            background: white;
            border-radius: 4px;
            padding: 2px;
        }

        .preview-scroll {
            max-height: 80vh;
            overflow-y: auto;
            border: 1px solid #e2e8f0;
            padding: 2rem;
            background: #f1f5f9;
        }

        .copy-toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #1e293b;
            color: white;
            padding: 12px 24px;
            border-radius: 99px;
            z-index: 100;
            display: none;
            animation: slideUp 0.3s ease-out;
        }

        @keyframes slideUp { from { bottom: 0; opacity: 0; } to { bottom: 20px; opacity: 1; } }
        
        .block-control-btn {
            @apply w-6 h-6 flex items-center justify-center bg-white border border-slate-200 rounded shadow-sm text-[10px] hover:bg-slate-50 transition;
        }

        .switch {
            position: relative;
            display: inline-block;
            width: 40px;
            height: 20px;
        }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute; cursor: pointer; inset: 0;
            background-color: #cbd5e1; transition: .4s; border-radius: 20px;
        }
        .slider:before {
            position: absolute; content: ""; height: 14px; width: 14px;
            left: 3px; bottom: 3px; background-color: white; transition: .4s; border-radius: 50%;
        }
        input:checked + .slider { background-color: #3b82f6; }
        input:checked + .slider:before { transform: translateX(20px); }

        .question-card {
            transition: all 0.2s ease-in-out;
        }
        .question-card.collapsed .question-content {
            display: none;
        }
    </style>
</head>
<body class="p-4 md:p-8">
    <div id="toast" class="copy-toast">Copied to clipboard!</div>
    
    <div class="max-w-5xl mx-auto">
        <header class="mb-8 flex flex-col md:flex-row justify-between items-start md:items-center gap-4">
            <div>
                <h1 class="text-3xl font-bold text-slate-800">MCQ Table Maker</h1>
                <div class="flex items-center gap-4 mt-1">
                    <p class="text-slate-500 text-sm">Undo: Ctrl+Z | Redo: Ctrl+Y</p>
                    <div class="flex gap-2">
                        <button onclick="undo()" id="undoBtn" class="text-xs bg-white border px-2 py-1 rounded opacity-50">Undo</button>
                        <button onclick="redo()" id="redoBtn" class="text-xs bg-white border px-2 py-1 rounded opacity-50">Redo</button>
                    </div>
                </div>
            </div>
            <div class="flex flex-wrap gap-2">
                <input type="file" id="csvFileInput" accept=".csv" class="hidden" onchange="importCSV(event)">
                <button onclick="document.getElementById('csvFileInput').click()" class="bg-indigo-600 hover:bg-indigo-700 text-white px-4 py-2 rounded-lg text-sm transition">Import CSV</button>
                <button onclick="exportCSV()" class="bg-emerald-600 hover:bg-emerald-700 text-white px-4 py-2 rounded-lg text-sm transition">Export CSV</button>
                <button onclick="toggleAllCollapse(true)" class="bg-slate-200 hover:bg-slate-300 text-slate-700 px-3 py-2 rounded-lg text-sm transition">Collapse All</button>
                <button onclick="toggleAllCollapse(false)" class="bg-slate-200 hover:bg-slate-300 text-slate-700 px-3 py-2 rounded-lg text-sm transition">Unfold All</button>
                <button onclick="smartPasteAll()" class="bg-amber-500 hover:bg-amber-600 text-white px-4 py-2 rounded-lg text-sm transition">‚ö° Smart Paste All</button>
                <button onclick="addQuestion()" class="bg-blue-600 hover:bg-blue-700 text-white px-4 py-2 rounded-lg text-sm transition">+ Add Question</button>
                <button onclick="toggleExportMode()" class="bg-slate-800 hover:bg-slate-900 text-white px-4 py-2 rounded-lg text-sm transition">Full Preview</button>
            </div>
        </header>

        <div id="questionsContainer" class="space-y-4 mb-12"></div>

        <div class="border-t pt-8 pb-16 flex flex-wrap justify-center gap-4">
             <button onclick="smartPasteAll()" class="bg-amber-500 hover:bg-amber-600 text-white px-6 py-3 rounded-xl font-bold shadow-lg transition transform hover:-translate-y-1">
                ‚ö° Smart Paste All
             </button>
             <button onclick="addQuestion()" class="bg-blue-600 hover:bg-blue-700 text-white px-6 py-3 rounded-xl font-bold shadow-lg transition transform hover:-translate-y-1">
                + Add Another Question
             </button>
             <button onclick="toggleExportMode()" class="bg-slate-800 hover:bg-slate-900 text-white px-6 py-3 rounded-xl font-bold shadow-lg transition transform hover:-translate-y-1">
                Preview & Export All
             </button>
        </div>

        <!-- Export Modal -->
        <div id="exportModal" class="hidden fixed inset-0 bg-black/50 backdrop-blur-sm z-50 flex items-center justify-center p-4">
            <div class="bg-white rounded-xl max-w-5xl w-full max-h-[90vh] overflow-hidden flex flex-col shadow-2xl">
                <div class="flex flex-col md:flex-row justify-between items-start md:items-center p-6 border-b gap-4">
                    <div>
                        <h2 class="text-xl font-bold">Word Export Preview</h2>
                        <div class="flex items-center gap-3 mt-1">
                            <label class="switch">
                                <input type="checkbox" id="mergeTablesToggle" onchange="refreshExportPreview()">
                                <span class="slider"></span>
                            </label>
                            <span class="text-xs font-semibold text-slate-600">One Big Table Mode</span>
                        </div>
                    </div>
                    <div class="flex gap-2">
                        <button onclick="copyAllTables()" class="bg-blue-600 text-white px-6 py-2 rounded-lg font-semibold hover:bg-blue-700">Copy for Word</button>
                        <button onclick="toggleExportMode()" class="bg-slate-100 px-4 py-2 rounded-lg hover:bg-slate-200">Close</button>
                    </div>
                </div>
                <div class="preview-scroll p-4 md:p-12">
                    <div id="exportArea" class="bg-white mx-auto" style="max-width: 8.5in; color: black;"></div>
                </div>
            </div>
        </div>
    </div>

    <div id="singleCopyBuffer" style="position: absolute; left: -9999px;"></div>

    <script>
        let questions = [];
        let history = [];
        let historyIndex = -1;

        function saveState() {
            const currentState = JSON.stringify(questions);
            if (historyIndex >= 0 && currentState === history[historyIndex]) return;
            if (historyIndex < history.length - 1) history = history.slice(0, historyIndex + 1);
            history.push(currentState);
            if (history.length > 50) history.shift();
            historyIndex = history.length - 1;
            updateHistoryButtons();
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                questions = JSON.parse(history[historyIndex]);
                renderQuestions(false);
                updateHistoryButtons();
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                questions = JSON.parse(history[historyIndex]);
                renderQuestions(false);
                updateHistoryButtons();
            }
        }

        function updateHistoryButtons() {
            const u = document.getElementById('undoBtn');
            const r = document.getElementById('redoBtn');
            u.disabled = historyIndex <= 0;
            r.disabled = historyIndex >= history.length - 1;
            u.style.opacity = u.disabled ? "0.3" : "1";
            r.style.opacity = r.disabled ? "0.3" : "1";
        }

        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'z') { e.preventDefault(); undo(); }
                if (e.key === 'y') { e.preventDefault(); redo(); }
            }
        });

        function renderQuestions(shouldSave = true) {
            if (shouldSave) saveState();
            const container = document.getElementById('questionsContainer');
            container.innerHTML = '';

            questions.forEach((q, qIdx) => {
                const card = document.createElement('div');
                card.id = `q-card-${qIdx}`;
                card.className = `question-card bg-white border rounded-xl shadow-sm overflow-hidden ${q.collapsed ? 'collapsed border-slate-300' : 'border-slate-200'}`;
                
                const cardTitle = q.text.substring(0, 120) + (q.text.length > 120 ? '...' : '');

                card.innerHTML = `
                    <div class="bg-slate-50 px-4 py-2 border-b flex justify-between items-center cursor-pointer select-none" onclick="toggleCollapse(${qIdx}, event)">
                        <div class="flex gap-3 items-center overflow-hidden">
                            <span class="text-[10px] font-bold text-slate-500 uppercase flex-shrink-0">Q${qIdx + 1}</span>
                            <div class="flex gap-1 flex-shrink-0">
                                <button onclick="moveQuestion(${qIdx}, -1, event)" class="text-[14px] text-slate-400 hover:text-blue-600 px-1">‚Üë</button>
                                <button onclick="moveQuestion(${qIdx}, 1, event)" class="text-[14px] text-slate-400 hover:text-blue-600 px-1">‚Üì</button>
                            </div>
                            ${q.collapsed ? `<span class="text-xs text-slate-600 tnr truncate">${cardTitle}</span>` : ''}
                        </div>
                        <div class="flex gap-2 flex-shrink-0">
                            <button onclick="copyQuestionTable(${qIdx}, event)" class="text-[10px] bg-white border border-blue-100 text-blue-600 px-2 py-0.5 rounded hover:bg-blue-50">Copy Table</button>
                            <button onclick="deleteQuestion(${qIdx}, event)" class="text-red-400 hover:text-red-600 ml-2">‚úï</button>
                            <span class="text-slate-400 text-xs ml-2">${q.collapsed ? '‚ñº' : '‚ñ≤'}</span>
                        </div>
                    </div>
                    <div class="question-content p-6 space-y-4">
                        <div class="flex gap-4">
                            <div class="tnr text-lg text-slate-400">${qIdx + 1}.</div>
                            <div class="flex-1">
                                <div contenteditable="true" class="editable tnr text-lg outline-none" onblur="updateQuestionText(${qIdx}, this.innerText)">${q.text}</div>
                            </div>
                        </div>

                        <div class="space-y-2">${q.blocks.map((block, bIdx) => renderBlock(qIdx, bIdx, block)).join('')}</div>
                        
                        <div class="flex flex-wrap items-center gap-2 pt-2 border-t mt-4">
                            <button onclick="addBlock(${qIdx}, 'text')" class="text-[10px] bg-slate-100 px-2 py-1 rounded hover:bg-slate-200">+ Text</button>
                            <button onclick="addBlock(${qIdx}, 'list')" class="text-[10px] bg-slate-100 px-2 py-1 rounded hover:bg-slate-200">+ List</button>
                            <button onclick="addBlock(${qIdx}, 'code')" class="text-[10px] bg-slate-100 px-2 py-1 rounded hover:bg-slate-200">+ Code</button>
                            <div class="w-[1px] h-4 bg-slate-200 mx-1"></div>
                            <button onclick="smartPasteList(${qIdx})" class="text-[10px] bg-indigo-50 text-indigo-600 px-2 py-1 rounded hover:bg-indigo-100">üìã List</button>
                            <button onclick="smartPasteCode(${qIdx})" class="text-[10px] bg-blue-50 text-blue-600 px-2 py-1 rounded hover:bg-blue-100">üìã Code</button>
                            <button onclick="smartPasteOptions(${qIdx})" class="text-[10px] bg-pink-50 text-pink-600 px-2 py-1 rounded hover:bg-pink-100">üìã ABCD Options</button>
                            <button onclick="smartPasteAnswer(${qIdx})" class="text-[10px] bg-emerald-50 text-emerald-600 px-2 py-1 rounded hover:bg-emerald-100">‚úÖ Ans</button>
                        </div>

                        <div class="grid grid-cols-1 md:grid-cols-2 gap-x-12 gap-y-4 pt-6 mt-4 border-t">
                            ${q.options.map((opt, oIdx) => `
                                <div class="flex items-start gap-3 p-2 rounded group ${q.answer === oIdx ? 'bg-blue-50/50' : ''}">
                                    <div class="flex flex-col items-center gap-1">
                                        <button onclick="setAnswer(${qIdx}, ${oIdx})" class="tnr w-7 h-7 flex-shrink-0 flex items-center justify-center rounded border font-medium ${q.answer === oIdx ? 'bg-blue-600 text-white border-blue-600' : 'bg-white text-slate-500 hover:bg-blue-50'}">${opt.label}</button>
                                        <div class="flex opacity-0 group-hover:opacity-100 transition">
                                            <button onclick="moveOption(${qIdx}, ${oIdx}, -1)" class="text-[8px] px-0.5 text-slate-400 hover:text-blue-600">‚Üë</button>
                                            <button onclick="moveOption(${qIdx}, ${oIdx}, 1)" class="text-[8px] px-0.5 text-slate-400 hover:text-blue-600">‚Üì</button>
                                        </div>
                                    </div>
                                    <div class="flex-1">
                                        <div contenteditable="true" class="editable tnr outline-none min-h-[1.5rem] ${opt.isCode ? 'courier text-sm' : ''} ${q.answer === oIdx ? 'underline decoration-blue-200 underline-offset-4' : ''}" onblur="updateOptionText(${qIdx}, ${oIdx}, this.innerText)">${opt.text}</div>
                                        <button onclick="toggleOptionStyle(${qIdx}, ${oIdx})" class="text-[8px] text-slate-300 uppercase hover:text-blue-500 mt-1 block">Toggle Mono</button>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
                container.appendChild(card);
            });
        }

        function renderBlock(qIdx, bIdx, block) {
            const indentLevel = block.indent || 0;
            const indentPx = indentLevel * 24;
            let content = '';
            
            if (block.type === 'text') {
                content = `<div contenteditable="true" class="editable tnr outline-none py-1 border-b border-dashed border-slate-100" style="margin-left:${indentPx}px" onblur="updateBlockContent(${qIdx}, ${bIdx}, this.innerText)">${block.content}</div>`;
            } else if (block.type === 'code') {
                content = `<div contenteditable="true" class="editable courier bg-slate-50 p-2 rounded text-sm shadow-inner" style="margin-left:${indentPx}px" onblur="updateBlockContent(${qIdx}, ${bIdx}, this.innerText)">${block.content}</div>`;
            } else if (block.type === 'list') {
                content = `
                    <div class="space-y-1" style="margin-left:${indentPx}px">
                        ${block.items.map((it, iIdx) => `
                            <div class="flex gap-2 group/item">
                                <div class="flex flex-col opacity-0 group-hover/item:opacity-100 transition pt-1">
                                    <button onclick="moveListItem(${qIdx}, ${bIdx}, ${iIdx}, -1)" class="text-[7px] text-slate-300 hover:text-blue-600">‚ñ≤</button>
                                    <button onclick="moveListItem(${qIdx}, ${bIdx}, ${iIdx}, 1)" class="text-[7px] text-slate-300 hover:text-blue-600">‚ñº</button>
                                </div>
                                <div contenteditable="true" class="tnr w-10 text-slate-400 font-bold outline-none" onblur="updateListItemLabel(${qIdx}, ${bIdx}, ${iIdx}, this.innerText)">${it.label}</div>
                                <div contenteditable="true" class="tnr flex-1 outline-none min-h-[1.2rem]" onblur="updateListItemText(${qIdx}, ${bIdx}, ${iIdx}, this.innerText)">${it.text}</div>
                                <button onclick="removeListItem(${qIdx}, ${bIdx}, ${iIdx})" class="opacity-0 group-hover/item:opacity-100 text-red-300 hover:text-red-500 px-1">‚úï</button>
                            </div>
                        `).join('')}
                        <button onclick="addListItem(${qIdx}, ${bIdx})" class="text-[9px] text-blue-400 font-bold ml-12 uppercase tracking-tight hover:underline">+ New Item</button>
                    </div>`;
            }

            return `
                <div class="relative group border border-transparent hover:border-slate-100 p-2 rounded-lg transition-colors">
                    <div class="flex justify-between items-center mb-1">
                        <div class="flex items-center gap-2">
                            <span class="text-[8px] font-black text-slate-300 uppercase tracking-widest">${block.type}</span>
                            <div class="flex gap-1 opacity-0 group-hover:opacity-100 transition">
                                <button onclick="adjustIndent(${qIdx}, ${bIdx}, -1)" class="block-control-btn">‚Üê</button>
                                <button onclick="adjustIndent(${qIdx}, ${bIdx}, 1)" class="block-control-btn">‚Üí</button>
                                <button onclick="moveBlock(${qIdx}, ${bIdx}, -1)" class="block-control-btn">‚Üë</button>
                                <button onclick="moveBlock(${qIdx}, ${bIdx}, 1)" class="block-control-btn">‚Üì</button>
                            </div>
                        </div>
                        <button onclick="deleteBlock(${qIdx}, ${bIdx})" class="opacity-0 group-hover:opacity-100 text-red-300 hover:text-red-500 px-1">‚úï</button>
                    </div>
                    ${content}
                </div>
            `;
        }

        function updateQuestionText(qIdx, text) { if(questions[qIdx].text !== text) { questions[qIdx].text = text; saveState(); } }
        function updateOptionText(qIdx, oIdx, text) { if(questions[qIdx].options[oIdx].text !== text) { questions[qIdx].options[oIdx].text = text; saveState(); } }
        function updateBlockContent(qIdx, bIdx, text) { if(questions[qIdx].blocks[bIdx].content !== text) { questions[qIdx].blocks[bIdx].content = text; saveState(); } }
        function updateListItemLabel(qIdx, bIdx, iIdx, val) { questions[qIdx].blocks[bIdx].items[iIdx].label = val; saveState(); }
        function updateListItemText(qIdx, bIdx, iIdx, val) { questions[qIdx].blocks[bIdx].items[iIdx].text = val; saveState(); }
        
        function setAnswer(qIdx, oIdx) { questions[qIdx].answer = questions[qIdx].answer === oIdx ? null : oIdx; renderQuestions(); }
        function toggleOptionStyle(qIdx, oIdx) { questions[qIdx].options[oIdx].isCode = !questions[qIdx].options[oIdx].isCode; renderQuestions(); }
        
        function toggleCollapse(idx, e) {
            questions[idx].collapsed = !questions[idx].collapsed;
            renderQuestions(false);
        }

        function toggleAllCollapse(collapsed) {
            questions.forEach(q => q.collapsed = collapsed);
            renderQuestions(false);
        }

        function moveQuestion(idx, dir, e) {
            if (e) e.stopPropagation();
            const target = idx + dir;
            if (target >= 0 && target < questions.length) {
                [questions[idx], questions[target]] = [questions[target], questions[idx]];
                renderQuestions();
                
                setTimeout(() => {
                    const el = document.getElementById(`q-card-${target}`);
                    if (el) {
                        el.scrollIntoView({ behavior: 'smooth', block: 'center' });
                        el.classList.add('ring-2', 'ring-blue-400');
                        setTimeout(() => el.classList.remove('ring-2', 'ring-blue-400'), 1000);
                    }
                }, 100);
            }
        }

        function moveBlock(qIdx, bIdx, dir) {
            const blocks = questions[qIdx].blocks;
            const target = bIdx + dir;
            if (target >= 0 && target < blocks.length) {
                [blocks[bIdx], blocks[target]] = [blocks[target], blocks[bIdx]];
                renderQuestions();
            }
        }

        function moveListItem(qIdx, bIdx, iIdx, dir) {
            const items = questions[qIdx].blocks[bIdx].items;
            const target = iIdx + dir;
            if (target >= 0 && target < items.length) {
                [items[iIdx], items[target]] = [items[target], items[iIdx]];
                renderQuestions();
            }
        }

        function moveOption(qIdx, oIdx, dir) {
            const opts = questions[qIdx].options;
            const target = oIdx + dir;
            if (target >= 0 && target < opts.length) {
                const tempLabel = opts[oIdx].label;
                opts[oIdx].label = opts[target].label;
                opts[target].label = tempLabel;
                [opts[oIdx], opts[target]] = [opts[target], opts[oIdx]];
                if (questions[qIdx].answer === oIdx) questions[qIdx].answer = target;
                else if (questions[qIdx].answer === target) questions[qIdx].answer = oIdx;
                renderQuestions();
            }
        }

        function adjustIndent(qIdx, bIdx, dir) {
            questions[qIdx].blocks[bIdx].indent = Math.max(0, Math.min(6, (questions[qIdx].blocks[bIdx].indent || 0) + dir));
            renderQuestions();
        }

        function deleteQuestion(i, e) { if (e) e.stopPropagation(); questions.splice(i, 1); renderQuestions(); }
        function deleteBlock(qIdx, bIdx) { questions[qIdx].blocks.splice(bIdx, 1); renderQuestions(); }
        function removeListItem(qIdx, bIdx, iIdx) { questions[qIdx].blocks[bIdx].items.splice(iIdx, 1); renderQuestions(); }

        function addQuestion() {
            questions.push({
                text: "Question Title...",
                blocks: [],
                options: [{label:"A.",text:""},{label:"B.",text:""},{label:"C.",text:""},{label:"D.",text:""}],
                answer: null,
                collapsed: false
            });
            renderQuestions();
        }

        function addBlock(qIdx, type) {
            const defaultIndent = type === 'text' ? 0 : 1;
            const b = { type, indent: defaultIndent };
            if (type === 'list') b.items = [{ label: "(1)", text: "" }];
            else b.content = "";
            questions[qIdx].blocks.push(b);
            renderQuestions();
        }

        function addListItem(qIdx, bIdx) {
            const items = questions[qIdx].blocks[bIdx].items;
            items.push({ label: `(${items.length + 1})`, text: "" });
            renderQuestions();
        }

        async function smartPasteAnswer(qIdx) {
            try {
                const text = await navigator.clipboard.readText();
                const match = text.match(/(?:Ans|Answer|Key)?[:\s]*\[?([A-D])\]?/i);
                if (match) {
                    questions[qIdx].answer = match[1].toUpperCase().charCodeAt(0) - 65;
                    renderQuestions();
                    showToast(`Answer set to ${match[1].toUpperCase()}`);
                }
            } catch (e) {}
        }

        async function smartPasteOptions(qIdx) {
             try {
                const text = await navigator.clipboard.readText();
                const lines = text.split(/\n/).map(l => l.trim()).filter(l => l);
                lines.forEach(line => {
                    const match = line.match(/^([A-D])[\.\s:]+(.*)/i);
                    if (match) {
                        const idx = match[1].toUpperCase().charCodeAt(0) - 65;
                        if (idx >= 0 && idx < 4) {
                            questions[qIdx].options[idx].text = match[2];
                        }
                    }
                });
                renderQuestions();
                showToast("Options updated");
            } catch (e) {}
        }

        async function smartPasteList(qIdx) {
            try {
                const text = await navigator.clipboard.readText();
                const lines = text.split(/\r?\n/).map(l => l.trim()).filter(l => l);
                const listItems = [];
                lines.forEach(line => {
                    const match = line.match(/^[\(\[]?(\d+)[\)\]\.\s]+(.*)/);
                    if (match) listItems.push({ label: `(${match[1]})`, text: match[2] });
                    else if (listItems.length > 0) listItems[listItems.length-1].text += " " + line;
                });
                if (listItems.length) {
                    questions[qIdx].blocks.push({ type: 'list', items: listItems, indent: 1 });
                    renderQuestions();
                }
            } catch (e) {}
        }

        async function smartPasteCode(qIdx) {
            try {
                const text = await navigator.clipboard.readText();
                if (text) {
                    questions[qIdx].blocks.push({ type: 'code', content: text, indent: 1 });
                    renderQuestions();
                }
            } catch (e) {}
        }

        async function smartPasteAll() {
            try {
                const text = await navigator.clipboard.readText();
                if (!text) return;
                const chunks = text.split(/\[Q\]:/g).filter(c => c.trim());
                const results = chunks.map(chunk => {
                    const lines = chunk.split(/\n/).map(l => l.trim()).filter(l => l);
                    const q = { text: "", blocks: [], options: [{label:"A.",text:""},{label:"B.",text:""},{label:"C.",text:""},{label:"D.",text:""}], answer: null, collapsed: false };
                    let parsingOpt = false;
                    
                    lines.forEach(line => {
                        const optMatch = line.match(/^([A-D])[\.\s:]+(.*)/i);
                        const listMatch = line.match(/^[\(\[]?(\d+)[\)\]\.\s]+(.*)/);

                        if (optMatch) {
                            q.options[optMatch[1].toUpperCase().charCodeAt(0)-65].text = optMatch[2];
                            parsingOpt = true;
                        } else if (listMatch && !parsingOpt) {
                            let lastBlock = q.blocks[q.blocks.length - 1];
                            if (!lastBlock || lastBlock.type !== 'list') {
                                lastBlock = { type: 'list', items: [], indent: 1 };
                                q.blocks.push(lastBlock);
                            }
                            lastBlock.items.push({ label: `(${listMatch[1]})`, text: listMatch[2] });
                        } else if (!parsingOpt) {
                            q.text += (q.text ? " " : "") + line;
                        }
                    });
                    return q;
                });
                questions = [...questions, ...results];
                renderQuestions();
            } catch (e) {}
        }

        const rowStyle = 'margin:0; padding:0; border:none; line-height:1.2;';
        const cellStyle = 'vertical-align:top; border:none; padding: 0; margin: 0;';

        function getQuestionRowsHTML(q, idx, isPartOfBigTable = false) {
            let html = '';
            html += `<tr style="${rowStyle}"><td style="width:30pt; ${cellStyle}">${idx + 1}.</td><td colspan="10" style="${cellStyle}">${q.text}</td></tr>`;
            
            q.blocks.forEach(block => {
                const indent = block.indent || 0;
                const spacerColumns = Array(indent).fill(`<td style="width:30pt; ${cellStyle}"></td>`).join('');
                const remainingColspan = 10 - indent;

                if (block.type === 'list') {
                    block.items.forEach(it => {
                        html += `<tr style="${rowStyle}"><td style="width:30pt; ${cellStyle}"></td>${spacerColumns}<td style="width:35pt; ${cellStyle}">${it.label}</td><td colspan="${remainingColspan - 1}" style="${cellStyle}">${it.text}</td></tr>`;
                    });
                } else if (block.type === 'code') {
                    const formattedCode = block.content.split('\n').map(line => line.replace(/\s/g, '&nbsp;')).join('<br>');
                    html += `<tr style="${rowStyle}"><td style="width:30pt; ${cellStyle}"></td>${spacerColumns}<td colspan="${remainingColspan}" style="font-family:'Courier New', monospace; font-size:10pt; ${cellStyle}">${formattedCode}</td></tr>`;
                } else {
                    html += `<tr style="${rowStyle}"><td style="width:30pt; ${cellStyle}"></td>${spacerColumns}<td colspan="${remainingColspan}" style="${cellStyle}">${block.content}</td></tr>`;
                }
            });

            q.options.forEach((opt, oIdx) => {
                const isCorrect = q.answer === oIdx;
                const decoration = isCorrect ? "text-decoration: underline;" : "";
                const font = opt.isCode ? "font-family:'Courier New', monospace; font-size:10pt;" : "";
                html += `<tr style="${rowStyle}"><td style="width:30pt; ${cellStyle}"></td><td style="width:30pt; ${cellStyle}">${opt.label}</td><td colspan="9" style="${decoration} ${font} ${cellStyle}">${opt.text}</td></tr>`;
            });

            if (isPartOfBigTable) {
                html += `<tr style="${rowStyle}"><td colspan="11" style="${cellStyle} height: 20pt;"></td></tr>`;
            }
            return html;
        }

        function generateHTMLForQuestion(q, idx) {
            let html = `<table class="tnr" style="border-collapse: collapse; width: 100%; font-size: 11pt; color: black; background: transparent; margin-bottom: 20pt; border:none; padding:0;">`;
            html += getQuestionRowsHTML(q, idx);
            html += `</table>`;
            return html;
        }

        function refreshExportPreview() {
            const isBigTable = document.getElementById('mergeTablesToggle').checked;
            const container = document.getElementById('exportArea');
            if (isBigTable) {
                let html = `<table class="tnr" style="border-collapse: collapse; width: 100%; font-size: 11pt; color: black; background: transparent; border:none; padding:0;">`;
                questions.forEach((q, i) => html += getQuestionRowsHTML(q, i, true));
                html += `</table>`;
                container.innerHTML = html;
            } else {
                container.innerHTML = questions.map((q, i) => generateHTMLForQuestion(q, i)).join('');
            }
        }

        function copyQuestionTable(qIdx, e) {
            if (e) e.stopPropagation();
            const buffer = document.getElementById('singleCopyBuffer');
            buffer.innerHTML = generateHTMLForQuestion(questions[qIdx], qIdx);
            selectAndCopy(buffer);
        }

        function copyAllTables() {
            const area = document.getElementById('exportArea');
            selectAndCopy(area);
        }

        function selectAndCopy(el) {
            const range = document.createRange();
            range.selectNode(el);
            window.getSelection().removeAllRanges();
            window.getSelection().addRange(range);
            document.execCommand('copy');
            window.getSelection().removeAllRanges();
            showToast("Copied to clipboard!");
        }

        function toggleExportMode() {
            const m = document.getElementById('exportModal');
            if (m.classList.contains('hidden')) {
                refreshExportPreview();
                m.classList.remove('hidden');
            } else m.classList.add('hidden');
        }

        function exportCSV() {
            let csv = "\uFEFF[#Index],Content,Label,Details\n";
            questions.forEach((q, idx) => {
                csv += `"${idx + 1}","${q.text.replace(/"/g, '""')}","",""\n`;
                if (q.answer !== null) csv += `,"Answer","","${q.answer}"\n`; 
                q.blocks.forEach(b => {
                    if (b.type === 'list') {
                        b.items.forEach(it => csv += `,"List Item","${it.label}","${it.text.replace(/"/g, '""')}"\n`);
                    } else {
                        csv += `,"${b.type === 'code' ? 'Code' : 'Text'}","${b.indent || 0}","${b.content.replace(/"/g, '""')}"\n`;
                    }
                });
                q.options.forEach(o => csv += `,"Option","${o.label}","${o.text.replace(/"/g, '""')}"\n`);
            });
            const blob = new Blob([csv], { type: 'text/csv' });
            const link = document.createElement("a");
            link.href = URL.createObjectURL(blob);
            link.download = `mcq_project_${new Date().toISOString().slice(0,10)}.csv`;
            link.click();
        }

        // --- ROBUST CSV PARSER ---
        function parseCSV(text) {
            const result = [];
            let row = [];
            let cell = '';
            let inQuotes = false;
            
            for (let i = 0; i < text.length; i++) {
                const char = text[i];
                const next = text[i+1];
                
                if (inQuotes) {
                    if (char === '"' && next === '"') {
                        cell += '"';
                        i++;
                    } else if (char === '"') {
                        inQuotes = false;
                    } else {
                        cell += char;
                    }
                } else {
                    if (char === '"') {
                        inQuotes = true;
                    } else if (char === ',') {
                        row.push(cell);
                        cell = '';
                    } else if (char === '\n' || char === '\r') {
                        row.push(cell);
                        if (row.length > 0) result.push(row);
                        row = [];
                        cell = '';
                        if (char === '\r' && next === '\n') i++;
                    } else {
                        cell += char;
                    }
                }
            }
            if (cell || row.length > 0) {
                row.push(cell);
                result.push(row);
            }
            return result;
        }

        function importCSV(event) {
            const file = event.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(e) {
                const raw = e.target.result;
                const rows = parseCSV(raw);
                const newQs = [];
                let currentQ = null;

                rows.forEach((cells, i) => {
                    if (i === 0 || !cells.join('').trim()) return;
                    
                    const idx = cells[0];
                    const type = cells[1];
                    const label = cells[2];
                    const details = cells[3];
                    
                    // Detect start of new question
                    if (idx && /^\d+/.test(idx)) {
                        if (currentQ) newQs.push(currentQ);
                        currentQ = { text: type || "", blocks: [], options: [], answer: null, collapsed: false };
                    } else if (currentQ) {
                        const typeNormalized = type ? type.toLowerCase() : "";
                        if (typeNormalized === "option") {
                            currentQ.options.push({ label, text: details || "", isCode: false });
                        } else if (typeNormalized === "answer") {
                            currentQ.answer = parseInt(details);
                        } else if (typeNormalized === "list item") {
                            // Only append to the last block if it's already a list, otherwise create new
                            let last = currentQ.blocks[currentQ.blocks.length - 1];
                            if (!last || last.type !== 'list') {
                                last = { type: 'list', items: [], indent: 1 };
                                currentQ.blocks.push(last);
                            }
                            last.items.push({ label, text: details || "" });
                        } else if (typeNormalized === "code" || typeNormalized === "text") {
                            currentQ.blocks.push({ 
                                type: typeNormalized, 
                                content: details || "", 
                                indent: parseInt(label) || (typeNormalized === "text" ? 0 : 1) 
                            });
                        }
                    }
                });
                if (currentQ) newQs.push(currentQ);
                if (newQs.length) { 
                    questions = newQs; 
                    renderQuestions(); 
                    showToast("Import successful");
                }
                event.target.value = ''; // Reset input
            };
            reader.readAsText(file);
        }

        function showToast(msg) {
            const t = document.getElementById('toast');
            t.innerText = msg; t.style.display = 'block';
            setTimeout(() => t.style.display = 'none', 2000);
        }

        addQuestion();
    </script>
</body>
</html>
