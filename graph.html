<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Interactive Equation Grapher</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjs/11.8.0/math.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
            font-family: 'Inter', system-ui, -apple-system, sans-serif;
            touch-action: none; /* Prevents default browser zooming/panning */
        }
        canvas {
            display: block;
            cursor: crosshair;
            background-color: #ffffff;
            touch-action: none;
        }
        .ui-panel {
            backdrop-filter: blur(8px);
            background-color: rgba(255, 255, 255, 0.9);
        }
        .math-input:focus {
            outline: 2px solid #3b82f6;
        }
        .foldable-content {
            transition: max-height 0.3s ease-out, opacity 0.2s;
            max-height: 0;
            overflow: hidden;
            opacity: 0;
        }
        .foldable-content.open {
            max-height: 600px;
            opacity: 1;
        }
        .rotate-icon {
            transition: transform 0.3s;
        }
        .open .rotate-icon {
            transform: rotate(180deg);
        }
        /* Improve touch targets for iPad */
        button, input[type="checkbox"] {
            min-height: 32px;
            min-width: 32px;
        }
    </style>
</head>
<body class="bg-gray-100">

    <!-- Left UI Overlay -->
    <div class="fixed top-4 left-4 z-10 w-80 flex flex-col gap-4 max-h-[90vh] overflow-y-auto pr-2">
        <div class="ui-panel rounded-2xl shadow-xl border border-gray-200 overflow-hidden">
            <button onclick="toggleFold('grapher-content')" class="w-full p-4 flex items-center justify-between font-bold text-gray-800 bg-white/50 hover:bg-white/80 transition-colors">
                <span>Grapher</span>
                <svg class="rotate-icon" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
            </button>
            <div id="grapher-content" class="foldable-content open p-6 pt-2 space-y-4">
                <div id="equation-list" class="flex flex-col gap-3"></div>
                <button onclick="addEquation()" class="w-full py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg transition-colors font-medium flex items-center justify-center gap-2">
                    <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="5" x2="12" y1="19"></line><line x1="5" y1="12" x2="19" y1="12"></line></svg>
                    Add Equation
                </button>
                <div class="pt-2 border-t border-gray-100">
                    <label class="block text-xs font-semibold text-gray-500 mb-2 uppercase tracking-wider">Coordinate Font Size: <span id="font-size-val">10</span>px</label>
                    <input type="range" id="font-size-slider" min="8" max="24" value="10" step="1" class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer accent-blue-500" oninput="updateFontSize(this.value)">
                </div>
            </div>
        </div>
    </div>

    <!-- Top Right Point Explorer -->
    <div class="fixed top-4 right-4 z-10 w-64 flex flex-col gap-2">
        <div class="ui-panel rounded-2xl shadow-xl border border-gray-200 overflow-hidden">
            <button onclick="toggleFold('explorer-content')" class="w-full p-4 flex items-center justify-between font-bold text-gray-700 bg-white/50 hover:bg-white/80 transition-colors">
                <span>Point Explorer</span>
                <svg class="rotate-icon" xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"></polyline></svg>
            </button>
            <div id="explorer-content" class="foldable-content p-4 space-y-3 bg-white/30">
                <div>
                    <label class="text-xs font-bold text-gray-500 uppercase">Input X</label>
                    <input type="text" id="explorer-x" placeholder="e.g. 5" class="w-full mt-1 bg-white border border-gray-200 rounded-lg px-2 py-1 text-sm math-input" oninput="updateExplorer('x', this.value)">
                </div>
                <div>
                    <label class="text-xs font-bold text-gray-500 uppercase">Input Y</label>
                    <input type="text" id="explorer-y" placeholder="e.g. 2" class="w-full mt-1 bg-white border border-gray-200 rounded-lg px-2 py-1 text-sm math-input" oninput="updateExplorer('y', this.value)">
                </div>
                <div id="explorer-status" class="text-center py-1 rounded text-xs font-bold transition-all"></div>
                <p class="text-[10px] text-gray-400 italic text-center">Checking first visible equation</p>
            </div>
        </div>
    </div>

    <!-- Bottom Zoom Controls -->
    <div class="fixed bottom-6 right-6 z-10 flex flex-col gap-2">
        <button onclick="zoom(0.8)" class="w-12 h-12 bg-white shadow-lg rounded-full flex items-center justify-center text-xl font-bold hover:bg-gray-50 active:scale-95 transition-all border border-gray-200">+</button>
        <button onclick="zoom(1.2)" class="w-12 h-12 bg-white shadow-lg rounded-full flex items-center justify-center text-xl font-bold hover:bg-gray-50 active:scale-95 transition-all border border-gray-200">-</button>
        <button onclick="resetView()" class="w-12 h-12 bg-white shadow-lg rounded-full flex items-center justify-center text-sm font-bold hover:bg-gray-50 active:scale-95 transition-all border border-gray-200">RST</button>
    </div>

    <canvas id="graphCanvas"></canvas>

    <script>
        const canvas = document.getElementById('graphCanvas');
        const ctx = canvas.getContext('2d');
        const equationContainer = document.getElementById('equation-list');

        let width, height;
        let labelFontSize = 10;
        let explorerState = { x: null, y: null };
        
        let equations = [
            { id: 0, text: 'y-x = -2', color: '#111827', compiled: null, visible: false },
            { id: 1, text: 'x+4 = 2x^2', color: '#3b82f6', compiled: null, visible: false },
            { id: 2, text: '2y+x=3x-5', color: '#ef4444', compiled: null, visible: false },
            { id: 3, text: 'x=2y', color: '#10b981', compiled: null, visible: false },
            { id: 4, text: 'x+y-1', color: '#f59e0b', compiled: null, visible: false },
            { id: 5, text: '1/x+1/2y=1/8', color: '#8b5cf6', compiled: null, visible: false },
            { id: 6, text: '3y/4-2x/5+7 = 0', color: '#ec4899', compiled: null, visible: false }
        ];

        let scale = 50, offsetX = 0, offsetY = 0;
        let isDragging = false, lastMousePos = { x: 0, y: 0 };
        
        // Touch State
        let lastTouchDistance = null;
        let lastTouchPos = { x: 0, y: 0 };

        function init() {
            resize();
            window.addEventListener('resize', resize);
            
            // Mouse Events
            canvas.addEventListener('mousedown', startDragging);
            window.addEventListener('mousemove', drag);
            window.addEventListener('mouseup', stopDragging);
            canvas.addEventListener('wheel', handleWheel, { passive: false });

            // Touch Events
            canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
            canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
            canvas.addEventListener('touchend', handleTouchEnd, { passive: false });

            equations.forEach(eq => compileEquation(eq));
            renderUI();
            draw();
        }

        function resize() {
            width = window.innerWidth; height = window.innerHeight;
            canvas.width = width; canvas.height = height;
            draw();
        }

        function toggleFold(id) {
            const el = document.getElementById(id);
            const parent = el.parentElement;
            el.classList.toggle('open');
            parent.classList.toggle('open');
        }

        function updateFontSize(val) {
            labelFontSize = parseInt(val);
            document.getElementById('font-size-val').innerText = val;
            draw();
        }

        function updateExplorer(axis, val) {
            const num = parseFloat(val);
            explorerState[axis] = isNaN(num) ? null : num;
            updateExplorerStatus();
            draw();
        }

        function updateExplorerStatus() {
            const statusEl = document.getElementById('explorer-status');
            const firstVisible = equations.find(e => e.visible && e.compiled);
            
            if (explorerState.x !== null && explorerState.y !== null && firstVisible) {
                try {
                    const result = firstVisible.compiled.node.evaluate({ x: explorerState.x, y: explorerState.y });
                    const isSolution = Math.abs(result) < 0.001;
                    statusEl.innerText = isSolution ? "✓ Solution!" : "✗ Not a solution";
                    statusEl.className = `text-center py-1 rounded text-xs font-bold ${isSolution ? 'bg-green-100 text-green-700' : 'bg-red-100 text-red-700'}`;
                } catch(e) {
                    statusEl.innerText = "";
                    statusEl.className = "";
                }
            } else {
                statusEl.innerText = "";
                statusEl.className = "";
            }
        }

        function compileEquation(eq) {
            try {
                let formula = eq.text.trim();
                if (!formula) { eq.compiled = null; eq.error = false; return; }

                let expression;
                if (formula.includes('=')) {
                    const sides = formula.split('=');
                    expression = `(${sides[0]}) - (${sides[1]})`;
                    eq.error = false;
                } else {
                    if (formula.toLowerCase().includes('y') && formula.toLowerCase().includes('x')) {
                        eq.compiled = null;
                        eq.error = true;
                        return;
                    } else {
                        expression = `y - (${formula})`;
                        eq.error = false;
                    }
                }

                const node = math.parse(expression);
                eq.compiled = {
                    node: node,
                    evaluateY: (x) => solveRoot(vY => node.evaluate({ x, y: vY })),
                    evaluateX: (y) => solveRoot(vX => node.evaluate({ x: vX, y: y }))
                };
            } catch (e) {
                eq.compiled = null;
                eq.error = true;
            }
        }

        function solveRoot(f) {
            let low = -1000, high = 1000;
            let v0 = f(0);
            if (Math.abs(v0) < 0.0001) return 0;
            
            let vLow = f(low), vHigh = f(high);
            if (vLow * vHigh > 0) {
                for(let step = -100; step <= 100; step += 5) {
                    let v = f(step);
                    if (Math.abs(v) < 0.5) { low = step - 20; high = step + 20; break; }
                }
            }
            for(let i=0; i<25; i++) {
                let mid = (low + high) / 2;
                let v = f(mid);
                if (Math.abs(v) < 0.0001) return mid;
                if (f(low) * v < 0) high = mid; else low = mid;
            }
            return (low + high) / 2;
        }

        function updateEquation(id, text) {
            const eq = equations.find(e => e.id === id);
            if (eq) { eq.text = text; compileEquation(eq); draw(); renderUI(); }
        }

        function toggleVisibility(id) {
            const eq = equations.find(e => e.id === id);
            if (eq) { eq.visible = !eq.visible; draw(); updateExplorerStatus(); }
        }

        function addEquation() {
            const colors = ['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899'];
            equations.push({ id: Date.now(), text: '', color: colors[equations.length % colors.length], compiled: null, visible: true, error: false });
            renderUI();
        }

        function removeEquation(id) {
            equations = equations.filter(e => e.id !== id);
            renderUI(); draw(); updateExplorerStatus();
        }

        function renderUI() {
            equationContainer.innerHTML = '';
            equations.forEach(eq => {
                const div = document.createElement('div');
                div.className = "relative group";
                div.innerHTML = `
                    <div class="flex items-center gap-2">
                        <input type="checkbox" ${eq.visible ? 'checked' : ''} onchange="toggleVisibility(${eq.id})" class="w-4 h-4 rounded border-gray-300 text-blue-600 cursor-pointer">
                        <div class="w-3 h-8 rounded-full flex-shrink-0" style="background-color: ${eq.color}"></div>
                        <input type="text" value="${eq.text}" placeholder="Equation..." class="math-input flex-1 bg-gray-50 border border-gray-200 rounded-lg px-2 py-2 text-sm transition-all ${eq.error ? 'border-red-500 bg-red-50 text-red-600' : ''}" oninput="updateEquation(${eq.id}, this.value)">
                        <button onclick="removeEquation(${eq.id})" class="text-gray-400 hover:text-red-500 opacity-0 group-hover:opacity-100 transition-opacity"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg></button>
                    </div>
                `;
                equationContainer.appendChild(div);
            });
        }

        function toScreenX(x) { return width / 2 + (x - offsetX) * scale; }
        function toScreenY(y) { return height / 2 - (y - offsetY) * scale; }
        function toWorldX(sx) { return (sx - width / 2) / scale + offsetX; }
        function toWorldY(sy) { return (height / 2 - sy) / scale + offsetY; }

        function draw() {
            ctx.clearRect(0, 0, width, height);
            const xMin = toWorldX(0), xMax = toWorldX(width);
            const yMin = toWorldY(height), yMax = toWorldY(0);

            drawGrid(xMin, xMax, yMin, yMax);
            drawAxes();

            equations.forEach(eq => {
                if (!eq.compiled || !eq.visible || eq.error) return;
                ctx.beginPath();
                ctx.strokeStyle = eq.color;
                ctx.lineWidth = 2.5;
                let first = true;
                for (let sx = 0; sx <= width; sx += 2) {
                    const x = toWorldX(sx);
                    try {
                        const y = eq.compiled.evaluateY(x);
                        if (typeof y === 'number' && !isNaN(y) && isFinite(y)) {
                            const sy = toScreenY(y);
                            if (first) { ctx.moveTo(sx, sy); first = false; }
                            else { if (Math.abs(sy) < 10000) ctx.lineTo(sx, sy); else { ctx.moveTo(sx, sy); first = true; } }
                        } else { first = true; }
                    } catch (e) { first = true; }
                }
                ctx.stroke();
            });

            drawExplorer();
        }

        function drawExplorer() {
            if (explorerState.x === null && explorerState.y === null) return;
            const firstVisible = equations.find(e => e.visible && e.compiled);
            if (!firstVisible) return;

            let startX, startY, midX, midY, endX, endY;

            if (explorerState.x !== null && explorerState.y !== null) {
                midX = explorerState.x; midY = explorerState.y;
                startX = midX; startY = 0;
                endX = 0; endY = midY;
            } else if (explorerState.x !== null) {
                startX = explorerState.x; startY = 0;
                midX = startX; 
                midY = firstVisible.compiled.evaluateY(startX);
                endX = 0; endY = midY;
            } else {
                startX = 0; startY = explorerState.y;
                midY = startY;
                midX = firstVisible.compiled.evaluateX(startY);
                endX = midX; endY = 0;
            }

            if (isNaN(midX) || isNaN(midY)) return;

            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = '#6366f1';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(toScreenX(startX), toScreenY(startY));
            ctx.lineTo(toScreenX(midX), toScreenY(midY));
            ctx.lineTo(toScreenX(endX), toScreenY(endY));
            ctx.stroke();
            ctx.setLineDash([]);

            ctx.fillStyle = '#6366f1';
            ctx.beginPath(); ctx.arc(toScreenX(midX), toScreenY(midY), 5, 0, Math.PI * 2); ctx.fill();

            ctx.fillStyle = '#4338ca';
            ctx.font = `bold ${Math.max(12, labelFontSize)}px Inter`;
            ctx.fillText(`(${midX.toFixed(2)}, ${midY.toFixed(2)})`, toScreenX(midX) + 8, toScreenY(midY) - 8);
        }

        function drawGrid(xMin, xMax, yMin, yMax) {
            let baseStep = Math.pow(10, Math.floor(Math.log10(100 / scale)));
            const steps = [baseStep, baseStep * 2, baseStep * 5];
            let step = steps.find(s => (s * scale) >= 50) || baseStep;
            ctx.lineWidth = 1;
            ctx.font = `${labelFontSize}px Inter, sans-serif`;
            for (let x = Math.floor(xMin / step) * step; x <= xMax; x += step) {
                const sx = toScreenX(x);
                ctx.strokeStyle = Math.abs(x) < step/2 ? '#000' : '#f1f1f1';
                ctx.beginPath(); ctx.moveTo(sx, 0); ctx.lineTo(sx, height); ctx.stroke();
                if (Math.abs(x) > step/2) { ctx.fillStyle = '#6b7280'; ctx.fillText(Number(x.toFixed(5)), sx + 2, toScreenY(0) + labelFontSize + 2); }
            }
            for (let y = Math.floor(yMin / step) * step; y <= yMax; y += step) {
                const sy = toScreenY(y);
                ctx.strokeStyle = Math.abs(y) < step/2 ? '#000' : '#f1f1f1';
                ctx.beginPath(); ctx.moveTo(0, sy); ctx.lineTo(width, sy); ctx.stroke();
                if (Math.abs(y) > step/2) { ctx.fillStyle = '#6b7280'; ctx.fillText(Number(y.toFixed(5)), toScreenX(0) + 4, sy - 2); }
            }
        }

        function drawAxes() {
            ctx.strokeStyle = '#374151'; ctx.lineWidth = 2;
            ctx.beginPath(); ctx.moveTo(0, toScreenY(0)); ctx.lineTo(width, toScreenY(0)); ctx.stroke();
            ctx.beginPath(); ctx.moveTo(toScreenX(0), 0); ctx.lineTo(toScreenX(0), height); ctx.stroke();
        }

        // Mouse Handlers
        function startDragging(e) { if (e.target.tagName === 'CANVAS') { isDragging = true; lastMousePos = { x: e.clientX, y: e.clientY }; } }
        function drag(e) { if (!isDragging) return; offsetX -= (e.clientX - lastMousePos.x) / scale; offsetY += (e.clientY - lastMousePos.y) / scale; lastMousePos = { x: e.clientX, y: e.clientY }; draw(); }
        function stopDragging() { isDragging = false; }
        function handleWheel(e) { e.preventDefault(); zoom(e.deltaY > 0 ? 1.1 : 0.9, e.clientX, e.clientY); }

        // Touch Handlers
        function handleTouchStart(e) {
            if (e.target.tagName !== 'CANVAS') return;
            e.preventDefault();
            
            if (e.touches.length === 1) {
                isDragging = true;
                lastTouchPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
            } else if (e.touches.length === 2) {
                isDragging = false; // Stop dragging if pinching
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
            }
        }

        function handleTouchMove(e) {
            if (e.target.tagName !== 'CANVAS') return;
            e.preventDefault();

            if (e.touches.length === 1 && isDragging) {
                const touch = e.touches[0];
                offsetX -= (touch.clientX - lastTouchPos.x) / scale;
                offsetY += (touch.clientY - lastTouchPos.y) / scale;
                lastTouchPos = { x: touch.clientX, y: touch.clientY };
                draw();
            } else if (e.touches.length === 2) {
                const dx = e.touches[0].clientX - e.touches[1].clientX;
                const dy = e.touches[0].clientY - e.touches[1].clientY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                if (lastTouchDistance) {
                    const ratio = lastTouchDistance / distance;
                    // Zoom towards the center between the two fingers
                    const centerX = (e.touches[0].clientX + e.touches[1].clientX) / 2;
                    const centerY = (e.touches[0].clientY + e.touches[1].clientY) / 2;
                    zoom(ratio, centerX, centerY);
                }
                lastTouchDistance = distance;
            }
        }

        function handleTouchEnd(e) {
            isDragging = false;
            lastTouchDistance = null;
        }

        function zoom(f, cx = width/2, cy = height/2) {
            const wx = toWorldX(cx), wy = toWorldY(cy);
            scale /= f; scale = Math.max(0.0001, Math.min(scale, 1000000));
            offsetX = wx - (cx - width/2)/scale; offsetY = wy - (height/2 - cy)/scale;
            draw();
        }
        
        function resetView() { scale = 50; offsetX = 0; offsetY = 0; draw(); }
        window.onload = init;
    </script>
</body>
</html>