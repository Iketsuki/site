<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Robo-Academy: AI Reasoning Lab</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@300;400;600&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Fredoka', sans-serif;
            background-color: #0f172a;
            color: #e2e8f0;
            overflow-x: hidden;
        }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }

        .glass-panel {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
        }

        canvas {
            image-rendering: pixelated; /* Sharp rendering for grid */
            cursor: pointer;
            touch-action: none;
        }

        .btn {
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }
        .btn:active { transform: scale(0.95); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn::after {
            content: '';
            position: absolute;
            top: 50%; left: 50%;
            width: 0; height: 0;
            background: rgba(255,255,255,0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.3s, height 0.3s;
        }
        .btn:active::after { width: 200px; height: 200px; }

        .stat-card {
            background: rgba(15, 23, 42, 0.6);
            border-radius: 8px;
            padding: 0.75rem;
            border: 1px solid rgba(255,255,255,0.05);
        }

        /* Checkbox Toggles */
        .toggle-checkbox:checked {
            right: 0;
            border-color: #3b82f6;
        }
        .toggle-checkbox:checked + .toggle-label {
            background-color: #3b82f6;
        }
        .toggle-checkbox:checked + .toggle-label:before {
            transform: translateX(100%);
        }

        /* Range Slider */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #3b82f6;
            margin-top: -6px;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: #334155;
            border-radius: 2px;
        }

        /* Animations */
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 15px rgba(56, 189, 248, 0.2); }
            50% { box-shadow: 0 0 25px rgba(56, 189, 248, 0.5); }
        }
        .animate-glow { animation: pulse-glow 2s infinite; }
        
        .grid-overlay {
            background-image: linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px),
            linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
            background-size: 20px 20px;
        }

        /* Summary Modal */
        .summary-overlay {
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(5px);
        }
    </style>
</head>
<body class="min-h-screen flex flex-col lg:flex-row">

    <!-- Sidebar Controls -->
    <div class="w-full lg:w-96 p-4 lg:p-6 flex flex-col gap-4 z-10 lg:h-screen lg:overflow-y-auto glass-panel border-r border-slate-700">
        
        <div class="mb-2">
            <h1 class="text-3xl font-bold bg-gradient-to-r from-blue-400 to-purple-400 bg-clip-text text-transparent">Robo-Academy</h1>
            <p class="text-slate-400 text-sm">Teach AI to think!</p>
        </div>

        <!-- Levels / Scaffolding -->
        <div class="space-y-2">
            <h2 class="text-sm font-semibold uppercase tracking-wider text-slate-400">Tutorial Levels</h2>
            <div class="grid grid-cols-3 gap-2">
                <button onclick="app.loadLevel('open')" class="btn bg-slate-700 hover:bg-slate-600 p-2 rounded-lg text-xs flex flex-col items-center gap-1 border border-slate-600">
                    <i class="fa-solid fa-wind text-green-400"></i> Open Field
                </button>
                <button onclick="app.loadLevel('trap')" class="btn bg-slate-700 hover:bg-slate-600 p-2 rounded-lg text-xs flex flex-col items-center gap-1 border border-slate-600">
                    <i class="fa-solid fa-magnet text-yellow-400"></i> The Trap
                </button>
                <button onclick="app.loadLevel('mud')" class="btn bg-slate-700 hover:bg-slate-600 p-2 rounded-lg text-xs flex flex-col items-center gap-1 border border-slate-600">
                    <i class="fa-solid fa-shoe-prints text-amber-600"></i> Muddy Choice
                </button>
            </div>
        </div>

        <!-- Reasoning Level Selector -->
        <div class="space-y-3">
            <h2 class="text-sm font-semibold uppercase tracking-wider text-slate-400">Select Reasoning Level</h2>
            
            <!-- Level 1: Skill -->
            <button onclick="app.setMode('skill')" id="btn-skill" class="btn w-full p-3 rounded-xl border border-slate-600 hover:bg-slate-700 text-left transition-colors group">
                <div class="flex items-center gap-3">
                    <div class="w-10 h-10 rounded-lg bg-green-500/20 text-green-400 flex items-center justify-center text-xl">
                        <i class="fa-solid fa-bolt"></i>
                    </div>
                    <div>
                        <div class="font-bold text-green-400">Skill-Based</div>
                        <div class="text-xs text-slate-400">Instinctive & Fast</div>
                    </div>
                </div>
            </button>

            <!-- Level 2: Rule -->
            <button onclick="app.setMode('rule')" id="btn-rule" class="btn w-full p-3 rounded-xl border border-slate-600 hover:bg-slate-700 text-left transition-colors group">
                <div class="flex items-center gap-3">
                    <div class="w-10 h-10 rounded-lg bg-yellow-500/20 text-yellow-400 flex items-center justify-center text-xl">
                        <i class="fa-solid fa-scroll"></i>
                    </div>
                    <div>
                        <div class="font-bold text-yellow-400">Rule-Based</div>
                        <div class="text-xs text-slate-400">Follows Logic/Heuristics</div>
                    </div>
                </div>
            </button>

            <!-- Level 3: Knowledge -->
            <button onclick="app.setMode('knowledge')" id="btn-knowledge" class="btn w-full p-3 rounded-xl border-2 border-blue-500 bg-blue-500/10 text-left transition-colors group relative overflow-hidden">
                <div class="absolute inset-0 bg-blue-500/5 group-hover:bg-blue-500/10 transition-colors"></div>
                <div class="flex items-center gap-3 relative z-10">
                    <div class="w-10 h-10 rounded-lg bg-blue-500/20 text-blue-400 flex items-center justify-center text-xl">
                        <i class="fa-solid fa-brain"></i>
                    </div>
                    <div>
                        <div class="font-bold text-blue-400">Knowledge-Based</div>
                        <div class="text-xs text-blue-200">Reinforcement Learning</div>
                    </div>
                </div>
            </button>
        </div>

        <!-- Brain Tweaks -->
        <div id="tweaks-panel" class="glass-panel p-4 bg-slate-800/50 hidden">
            <h3 class="font-bold mb-3 text-sm text-slate-200 flex items-center gap-2">
                <i class="fa-solid fa-sliders"></i> Brain Tweaks
            </h3>
            
            <div id="tweaks-skill" class="space-y-4 hidden">
                <label class="flex items-center justify-between cursor-pointer">
                    <span class="text-sm text-slate-300 font-bold">Survival Instinct</span>
                    <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                        <input type="checkbox" id="check-survival" class="toggle-checkbox absolute block w-5 h-5 rounded-full bg-white border-4 appearance-none cursor-pointer border-slate-600"/>
                        <label for="check-survival" class="toggle-label block overflow-hidden h-5 rounded-full bg-slate-600 cursor-pointer"></label>
                    </div>
                </label>
                <label class="flex items-center justify-between cursor-pointer">
                    <span class="text-sm text-slate-300 font-bold">Hyperactive</span>
                    <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                        <input type="checkbox" id="check-hyper" class="toggle-checkbox absolute block w-5 h-5 rounded-full bg-white border-4 appearance-none cursor-pointer border-slate-600"/>
                        <label for="check-hyper" class="toggle-label block overflow-hidden h-5 rounded-full bg-slate-600 cursor-pointer"></label>
                    </div>
                </label>
            </div>

            <div id="tweaks-rule" class="space-y-4 hidden">
                <label class="flex items-center justify-between cursor-pointer">
                    <span class="text-sm text-slate-300 font-bold">Fear Mud?</span>
                    <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                        <input type="checkbox" id="check-fear-mud" class="toggle-checkbox absolute block w-5 h-5 rounded-full bg-white border-4 appearance-none cursor-pointer border-slate-600"/>
                        <label for="check-fear-mud" class="toggle-label block overflow-hidden h-5 rounded-full bg-slate-600 cursor-pointer"></label>
                    </div>
                </label>
                <label class="flex items-center justify-between cursor-pointer">
                    <span class="text-sm text-slate-300 font-bold">No Backtracking?</span>
                    <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                        <input type="checkbox" id="check-no-back" class="toggle-checkbox absolute block w-5 h-5 rounded-full bg-white border-4 appearance-none cursor-pointer border-slate-600"/>
                        <label for="check-no-back" class="toggle-label block overflow-hidden h-5 rounded-full bg-slate-600 cursor-pointer"></label>
                    </div>
                </label>
            </div>

            <div id="tweaks-knowledge" class="space-y-4 hidden">
                <div>
                    <div class="flex justify-between items-center mb-1">
                        <span class="text-sm text-slate-300 font-bold">Training Time</span>
                        <span id="episodes-val" class="text-xs text-blue-400 font-mono">1500 eps</span>
                    </div>
                    <input type="range" id="slider-episodes" min="100" max="5000" step="100" value="1500" oninput="document.getElementById('episodes-val').innerText = this.value + ' eps'">
                </div>
                <label class="flex items-center justify-between cursor-pointer">
                    <span class="text-sm text-slate-300 font-bold">Hate Mud</span>
                    <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                        <input type="checkbox" id="check-hate-mud" class="toggle-checkbox absolute block w-5 h-5 rounded-full bg-white border-4 appearance-none cursor-pointer border-slate-600"/>
                        <label for="check-hate-mud" class="toggle-label block overflow-hidden h-5 rounded-full bg-slate-600 cursor-pointer"></label>
                    </div>
                </label>
                <label class="flex items-center justify-between cursor-pointer">
                    <span class="text-sm text-slate-300 font-bold">Hate Walls</span>
                    <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                        <input type="checkbox" id="check-hate-walls" class="toggle-checkbox absolute block w-5 h-5 rounded-full bg-white border-4 appearance-none cursor-pointer border-slate-600"/>
                        <label for="check-hate-walls" class="toggle-label block overflow-hidden h-5 rounded-full bg-slate-600 cursor-pointer"></label>
                    </div>
                </label>
            </div>
        </div>

        <!-- Description Box -->
        <div class="glass-panel p-4 bg-slate-800/50">
            <h3 id="desc-title" class="font-bold mb-2 text-blue-300">Knowledge-Based (AI)</h3>
            <p id="desc-text" class="text-sm text-slate-300 leading-relaxed">
                The agent simulates thousands of runs (episodes) to learn the entire map. It discovers that mud is slow and walls are blocked, eventually finding the true optimal path.
            </p>
        </div>

        <!-- Map Editor Tools -->
        <div class="space-y-2">
            <h2 class="text-sm font-semibold uppercase tracking-wider text-slate-400">Map Editor</h2>
            <div class="grid grid-cols-4 gap-2">
                <button onclick="app.setTool('wall')" class="btn tool-btn bg-slate-700 hover:bg-slate-600 p-2 rounded-lg flex flex-col items-center gap-1 active-tool ring-2 ring-blue-400" id="tool-wall">
                    <span class="text-xl">üß±</span>
                    <span class="text-[10px]">Wall</span>
                </button>
                <button onclick="app.setTool('mud')" class="btn tool-btn bg-slate-700 hover:bg-slate-600 p-2 rounded-lg flex flex-col items-center gap-1" id="tool-mud">
                    <span class="text-xl">üêå</span>
                    <span class="text-[10px]">Mud</span>
                </button>
                <button onclick="app.setTool('eraser')" class="btn tool-btn bg-slate-700 hover:bg-slate-600 p-2 rounded-lg flex flex-col items-center gap-1" id="tool-eraser">
                    <span class="text-xl">ü´ß</span>
                    <span class="text-[10px]">Eraser</span>
                </button>
                <button onclick="app.resetGrid()" class="btn bg-red-900/30 hover:bg-red-900/50 text-red-400 p-2 rounded-lg flex flex-col items-center gap-1">
                    <i class="fa-solid fa-trash text-lg"></i>
                    <span class="text-[10px]">Clear</span>
                </button>
            </div>
        </div>

        <!-- Action Buttons & Speed -->
        <div class="mt-auto space-y-3">
             <div id="training-controls" class="hidden">
                <div class="flex justify-between text-xs mb-1 text-slate-400">
                    <span>Training Progress</span>
                    <span id="train-episode">0 eps</span>
                </div>
                <div class="w-full bg-slate-700 rounded-full h-2 mb-3 overflow-hidden">
                    <div id="train-bar" class="bg-blue-500 h-2 rounded-full transition-all duration-75" style="width: 0%"></div>
                </div>
                <button onclick="app.trainAgent()" id="btn-train" class="btn w-full py-3 bg-indigo-600 hover:bg-indigo-500 rounded-xl font-bold shadow-lg shadow-indigo-500/20 flex items-center justify-center gap-2">
                    <i class="fa-solid fa-graduation-cap"></i> Train AI
                </button>
             </div>

            <div id="simulation-controls" class="w-full">
                <!-- Sim Speed Slider -->
                <div class="mb-3 px-1">
                     <div class="flex justify-between text-xs mb-1 text-slate-400">
                        <span>Speed</span>
                        <span id="speed-val">1x</span>
                    </div>
                    <input type="range" id="sim-speed" min="1" max="10" step="1" value="5" 
                           oninput="app.setSpeed(this.value)">
                </div>

                <!-- Initial Run Button -->
                <button onclick="app.runSimulation()" id="btn-run" class="btn w-full py-3 bg-emerald-600 hover:bg-emerald-500 rounded-xl font-bold shadow-lg shadow-emerald-500/20 flex items-center justify-center gap-2">
                    <i class="fa-solid fa-play"></i> Run Simulation
                </button>

                <!-- Active Controls (Pause/Reset) -->
                <div id="btn-group-active" class="hidden grid grid-cols-2 gap-2">
                    <button onclick="app.togglePause()" id="btn-pause" class="btn w-full py-3 bg-amber-500 hover:bg-amber-400 rounded-xl font-bold shadow-lg shadow-amber-500/20 flex items-center justify-center gap-2">
                        <i class="fa-solid fa-pause"></i> Pause
                    </button>
                    <button onclick="app.stopSimulation()" id="btn-stop" class="btn w-full py-3 bg-red-500 hover:bg-red-400 rounded-xl font-bold shadow-lg shadow-red-500/20 flex items-center justify-center gap-2">
                        <i class="fa-solid fa-stop"></i> Reset
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Viewport -->
    <div class="flex-1 p-2 lg:p-8 flex flex-col items-center justify-center bg-[#0b1120] relative overflow-hidden">
        <!-- Background Decor -->
        <div class="absolute top-0 left-0 w-full h-full grid-overlay opacity-30 pointer-events-none"></div>
        <div class="absolute top-10 right-10 w-64 h-64 bg-blue-500/10 rounded-full blur-3xl pointer-events-none"></div>

        <!-- Header for Canvas -->
        <div class="flex justify-between items-center w-full max-w-2xl mb-4 z-10">
            <div class="flex gap-4 text-sm font-mono">
                <div class="flex items-center gap-2"><span class="w-3 h-3 rounded-full bg-blue-500"></span> Start</div>
                <div class="flex items-center gap-2"><span class="w-3 h-3 rounded-full bg-red-500"></span> Goal</div>
            </div>
            <div id="status-badge" class="px-3 py-1 rounded-full bg-slate-800 border border-slate-700 text-xs font-mono text-slate-300">
                Ready
            </div>
        </div>

        <!-- Canvas Container -->
        <div class="relative canvas-container group">
            <canvas id="gridCanvas" width="600" height="600" class="shadow-2xl shadow-black/50"></canvas>
            
            <!-- Floating Stats (visible on hover or run) -->
            <div class="absolute -right-32 top-0 flex flex-col gap-2 transition-opacity duration-300 opacity-100 lg:opacity-100">
                <div class="stat-card w-28">
                    <div class="text-[10px] uppercase text-slate-500 font-bold">Steps</div>
                    <div id="stat-steps" class="text-xl font-mono text-white">0</div>
                </div>
                <div class="stat-card w-28">
                    <div class="text-[10px] uppercase text-slate-500 font-bold">Reward</div>
                    <div id="stat-reward" class="text-xl font-mono text-emerald-400">0</div>
                </div>
            </div>
            
            <!-- Summary Overlay (Hidden by default) -->
            <div id="summary-modal" class="hidden absolute inset-0 rounded-lg summary-overlay flex items-center justify-center p-6 z-50">
                <div class="bg-slate-900 border border-slate-700 p-6 rounded-2xl max-w-sm w-full shadow-2xl transform transition-all scale-100">
                    <div class="text-center mb-4">
                        <div id="summary-icon" class="text-4xl mb-2">üéâ</div>
                        <h3 id="summary-title" class="text-xl font-bold text-white">Result</h3>
                    </div>
                    <p id="summary-text" class="text-slate-300 text-sm mb-6 text-center leading-relaxed">
                        Explanation goes here...
                    </p>
                    <button onclick="app.closeSummary()" class="btn w-full py-2 bg-slate-700 hover:bg-slate-600 rounded-lg text-white font-semibold">
                        Close
                    </button>
                </div>
            </div>

        </div>
        
        <div class="mt-6 text-center max-w-lg text-slate-400 text-sm z-10">
            <i class="fa-solid fa-mouse pointer-events-none mr-1"></i> Click & Drag to draw walls. 
            <span class="hidden lg:inline">Right click to erase.</span>
        </div>

    </div>

    <script>
        // --- Configuration & Constants ---
        const GRID_SIZE = 15;
        const CELL_SIZE = 40; 
        const COLORS = {
            empty: '#1e293b',
            wall: '#94a3b8',
            mud: '#451a03', 
            start: '#3b82f6',
            goal: '#ef4444',
            path: '#eab308',
            visited: 'rgba(100, 116, 139, 0.2)',
            agent: '#fbbf24'
        };

        // --- Game Logic ---
        class RoboApp {
            constructor() {
                this.canvas = document.getElementById('gridCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.grid = [];
                this.mode = 'knowledge'; 
                this.tool = 'wall';
                this.isDrawing = false;
                this.startPos = {x: 1, y: 1};
                this.goalPos = {x: 13, y: 13};
                this.agentPos = { ...this.startPos };
                this.prevPos = { ...this.startPos }; 
                this.path = []; 
                
                this.isRunning = false;
                this.isPaused = false;
                this.simulationTimeout = null; // Changed to timeout for dynamic speed
                this.simSpeed = 5; // 1 to 10
                
                this.qTable = {}; 
                this.isTrained = false;
                
                this.steps = 0;
                this.totalReward = 0;

                this.initGrid();
                this.setupInputs();
                this.loop();
                this.setMode('knowledge'); 
            }

            initGrid() {
                this.grid = [];
                for(let y=0; y<GRID_SIZE; y++) {
                    let row = [];
                    for(let x=0; x<GRID_SIZE; x++) {
                        row.push(0); 
                    }
                    this.grid.push(row);
                }
            }

            // --- Level Loading (Scaffolding) ---
            loadLevel(type) {
                this.stopSimulation();
                this.initGrid();
                this.isTrained = false;
                this.startPos = {x:1, y:7};
                this.goalPos = {x:13, y:7};

                if (type === 'open') {
                    // Just open field, maybe a few random blocks
                    this.updateStatus('Level: Open Field', 'text-blue-300');
                    this.setMode('skill'); // Recommend skill mode
                } 
                else if (type === 'trap') {
                    // A U-shape trap
                    this.updateStatus('Level: The Trap', 'text-yellow-300');
                    for(let i=0; i<8; i++) {
                        this.grid[3+i][8] = 1; // Vertical wall
                    }
                    // Wings
                    this.grid[3][7] = 1; this.grid[3][6] = 1;
                    this.grid[10][7] = 1; this.grid[10][6] = 1;
                    this.setMode('rule'); // Recommend rule mode
                } 
                else if (type === 'mud') {
                    // Two paths: Straight through mud, or around
                    this.updateStatus('Level: Muddy Choice', 'text-amber-500');
                    // Wall separating paths
                    for(let x=3; x<12; x++) this.grid[5][x] = 1; 
                    for(let x=3; x<12; x++) this.grid[9][x] = 1;
                    
                    // Middle path (Muddy)
                    for(let x=2; x<13; x++) {
                         this.grid[7][x] = 2; 
                         this.grid[6][x] = 2;
                         this.grid[8][x] = 2;
                    }
                    this.setMode('knowledge'); // Recommend knowledge
                }

                this.agentPos = { ...this.startPos };
                this.path = [];
                this.draw();
            }

            // --- Simulation Speed ---
            setSpeed(val) {
                this.simSpeed = parseInt(val);
                document.getElementById('speed-val').innerText = val + 'x';
            }

            getDelay() {
                // Map 1-10 to delay. 1=1000ms, 10=50ms
                return 1000 - (this.simSpeed * 95); 
            }

            // --- Drawing ---
            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // 1. Draw Grid
                for(let y=0; y<GRID_SIZE; y++) {
                    for(let x=0; x<GRID_SIZE; x++) {
                        let type = this.grid[y][x];
                        let color = COLORS.empty;
                        
                        if (type === 1) color = COLORS.wall;
                        if (type === 2) color = COLORS.mud;
                        if (x === this.startPos.x && y === this.startPos.y) color = COLORS.start;
                        if (x === this.goalPos.x && y === this.goalPos.y) color = COLORS.goal;

                        this.ctx.fillStyle = color;
                        
                        let gap = 2;
                        this.ctx.fillRect(x*CELL_SIZE + gap, y*CELL_SIZE + gap, CELL_SIZE - gap*2, CELL_SIZE - gap*2);

                        if(type === 2) {
                            this.ctx.fillStyle = 'rgba(255,255,255,0.1)';
                            this.ctx.font = '20px Arial';
                            this.ctx.textAlign = 'center';
                            this.ctx.textBaseline = 'middle';
                            this.ctx.fillText('üêå', x*CELL_SIZE + CELL_SIZE/2, y*CELL_SIZE + CELL_SIZE/2);
                        }

                        if (this.mode === 'knowledge' && this.isTrained && type !== 1) {
                            this.drawQArrows(x, y);
                        }
                    }
                }

                // 2. Draw Path
                if (this.path.length > 1) {
                    this.ctx.beginPath();
                    this.ctx.strokeStyle = COLORS.path;
                    this.ctx.lineWidth = 4;
                    this.ctx.lineJoin = 'round';
                    this.ctx.lineCap = 'round';
                    this.ctx.globalAlpha = 0.6; 

                    const startX = this.path[0].x * CELL_SIZE + CELL_SIZE/2;
                    const startY = this.path[0].y * CELL_SIZE + CELL_SIZE/2;
                    this.ctx.moveTo(startX, startY);

                    for(let i=1; i<this.path.length; i++) {
                        const px = this.path[i].x * CELL_SIZE + CELL_SIZE/2;
                        const py = this.path[i].y * CELL_SIZE + CELL_SIZE/2;
                        this.ctx.lineTo(px, py);
                    }
                    const currX = this.agentPos.x * CELL_SIZE + CELL_SIZE/2;
                    const currY = this.agentPos.y * CELL_SIZE + CELL_SIZE/2;
                    this.ctx.lineTo(currX, currY);

                    this.ctx.stroke();
                    this.ctx.globalAlpha = 1.0;
                }

                // 3. Draw Agent
                const ax = this.agentPos.x * CELL_SIZE + CELL_SIZE/2;
                const ay = this.agentPos.y * CELL_SIZE + CELL_SIZE/2;
                
                this.ctx.fillStyle = COLORS.agent;
                this.ctx.beginPath();
                this.ctx.arc(ax, ay, CELL_SIZE/3, 0, Math.PI*2);
                this.ctx.fill();
                
                this.ctx.fillStyle = 'black';
                this.ctx.beginPath();
                this.ctx.arc(ax - 5, ay - 2, 2, 0, Math.PI*2);
                this.ctx.arc(ax + 5, ay - 2, 2, 0, Math.PI*2);
                this.ctx.fill();
            }

            drawQArrows(x, y) {
                if (x === this.goalPos.x && y === this.goalPos.y) return;
                const key = `${x},${y}`;
                if (!this.qTable[key]) return;
                
                const actions = this.qTable[key];
                let bestVal = -Infinity;
                let bestAct = null;
                for(let a in actions) {
                    if (actions[a] > bestVal) {
                        bestVal = actions[a];
                        bestAct = a;
                    }
                }

                if (bestVal > -999) {
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    this.ctx.font = '12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    let char = '';
                    if (bestAct === 'up') char = '‚Üë';
                    if (bestAct === 'down') char = '‚Üì';
                    if (bestAct === 'left') char = '‚Üê';
                    if (bestAct === 'right') char = '‚Üí';
                    this.ctx.fillText(char, x*CELL_SIZE + CELL_SIZE/2, y*CELL_SIZE + CELL_SIZE/2);
                }
            }

            // --- Agents Logic (Unchanged core logic) ---
            getSkillAction() {
                const survival = document.getElementById('check-survival').checked;
                const hyperactive = document.getElementById('check-hyper').checked;
                const moves = ['up', 'down', 'left', 'right'];
                
                if (hyperactive && Math.random() < 0.5) return moves[Math.floor(Math.random() * moves.length)];
                const validMoves = moves.filter(m => {
                    const next = this.getNextPos(this.agentPos.x, this.agentPos.y, m);
                    return !this.isWall(next.x, next.y);
                });
                if (survival && validMoves.length > 0) return validMoves[Math.floor(Math.random() * validMoves.length)];
                if (validMoves.length > 0 && Math.random() > 0.2) return validMoves[Math.floor(Math.random() * validMoves.length)];
                return moves[Math.floor(Math.random() * moves.length)];
            }

            getRuleAction() {
                const fearMud = document.getElementById('check-fear-mud').checked;
                const noBack = document.getElementById('check-no-back').checked;
                const moves = ['up', 'down', 'left', 'right'];
                let bestMove = moves[0];
                let minCost = Infinity;
                moves.sort(() => Math.random() - 0.5);
                let stuck = true;
                for (let m of moves) {
                    const next = this.getNextPos(this.agentPos.x, this.agentPos.y, m);
                    if (this.isWall(next.x, next.y)) continue;
                    if (noBack && next.x === this.prevPos.x && next.y === this.prevPos.y) {
                         if (moves.length > 1) continue; 
                    }
                    stuck = false;
                    let cost = Math.abs(next.x - this.goalPos.x) + Math.abs(next.y - this.goalPos.y);
                    if (fearMud && this.grid[next.y][next.x] === 2) cost += 10;
                    if (cost < minCost) { minCost = cost; bestMove = m; }
                }
                if (stuck) return moves[Math.floor(Math.random()*4)];
                return bestMove;
            }

            getKnowledgeAction() {
                if (!this.isTrained) return 'stop';
                const key = `${this.agentPos.x},${this.agentPos.y}`;
                const actions = this.qTable[key];
                if (!actions) return this.getSkillAction();
                let bestAct = null;
                let maxQ = -Infinity;
                for(let a in actions) {
                    if (actions[a] > maxQ) { maxQ = actions[a]; bestAct = a; }
                }
                return bestAct;
            }

            // --- Training ---
            async trainAgent() {
                this.isTrained = false;
                const episodes = parseInt(document.getElementById('slider-episodes').value) || 1500;
                const alpha = 0.5, gamma = 0.9, epsilon = 0.1;
                const hateMud = document.getElementById('check-hate-mud').checked;
                const hateWalls = document.getElementById('check-hate-walls').checked;
                const mudPenalty = hateMud ? -50 : -5;
                const wallPenalty = hateWalls ? -50 : -5;

                this.qTable = {}; 
                for(let y=0; y<GRID_SIZE; y++) {
                    for(let x=0; x<GRID_SIZE; x++) {
                        this.qTable[`${x},${y}`] = {up:0, down:0, left:0, right:0};
                    }
                }

                const btn = document.getElementById('btn-train');
                const bar = document.getElementById('train-bar');
                const epLabel = document.getElementById('train-episode');
                btn.disabled = true;
                btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Thinking...';

                let ep = 0;
                const trainChunk = () => {
                    const chunkSize = 50;
                    for(let k=0; k<chunkSize && ep < episodes; k++) {
                        let curr = { ...this.startPos };
                        let steps = 0;
                        while(steps < 100) {
                            let action;
                            if (Math.random() < epsilon) {
                                const moves = ['up','down','left','right'];
                                action = moves[Math.floor(Math.random()*4)];
                            } else {
                                let qs = this.qTable[`${curr.x},${curr.y}`];
                                action = Object.keys(qs).reduce((a, b) => qs[a] > qs[b] ? a : b);
                            }
                            let next = this.getNextPos(curr.x, curr.y, action);
                            let reward = -1; 
                            let isDone = false;
                            
                            if (next.x === this.goalPos.x && next.y === this.goalPos.y) {
                                reward = 100;
                                isDone = true;
                            } else if (this.isWall(next.x, next.y)) {
                                reward = wallPenalty;
                                next = curr; 
                            } else if (this.grid[next.y][next.x] === 2) { 
                                reward = mudPenalty; 
                            }
                            const currKey = `${curr.x},${curr.y}`;
                            const nextKey = `${next.x},${next.y}`;
                            const maxNextQ = Math.max(...Object.values(this.qTable[nextKey]));
                            const currentQ = this.qTable[currKey][action];
                            this.qTable[currKey][action] = currentQ + alpha * (reward + gamma * maxNextQ - currentQ);
                            curr = next;
                            steps++;
                            if (isDone) break;
                        }
                        ep++;
                    }
                    const progress = (ep / episodes) * 100;
                    bar.style.width = `${progress}%`;
                    epLabel.innerText = `${ep} / ${episodes}`;
                    if (ep < episodes) {
                        if (ep % 200 === 0) { this.isTrained = true; this.draw(); }
                        requestAnimationFrame(trainChunk);
                    } else {
                        this.isTrained = true;
                        this.draw();
                        btn.disabled = false;
                        btn.innerHTML = '<i class="fa-solid fa-graduation-cap"></i> Retrain';
                        this.updateStatus('Training Complete! Brain optimized.', 'text-green-400');
                    }
                };
                trainChunk();
            }

            // --- Simulation Logic ---
            runSimulation() {
                if (this.isRunning) return;
                
                if (this.mode === 'knowledge' && !this.isTrained) {
                    this.updateStatus('Please Train the AI first!', 'text-red-400');
                    return;
                }

                this.isRunning = true;
                this.isPaused = false;
                this.agentPos = { ...this.startPos };
                this.prevPos = { ...this.startPos };
                this.path = []; 
                this.steps = 0;
                this.totalReward = 0;

                this.updateUIForRun(true);
                this.updateStatus('Running...', 'text-blue-400');
                this.updateStatsUI();
                this.runStepLoop();
            }

            runStepLoop() {
                if (!this.isRunning) return;
                
                this.simulationStep();
                
                // Use Timeout for variable speed support
                if (this.isRunning && !this.isPaused) {
                    this.simulationTimeout = setTimeout(() => this.runStepLoop(), this.getDelay());
                }
            }

            togglePause() {
                if (!this.isRunning) return;
                this.isPaused = !this.isPaused;
                const btnPause = document.getElementById('btn-pause');
                
                if (this.isPaused) {
                    clearTimeout(this.simulationTimeout);
                    btnPause.innerHTML = '<i class="fa-solid fa-play"></i> Resume';
                    btnPause.className = "btn w-full py-3 bg-emerald-500 hover:bg-emerald-400 rounded-xl font-bold shadow-lg shadow-emerald-500/20 flex items-center justify-center gap-2";
                    this.updateStatus('Paused', 'text-amber-400');
                } else {
                    this.runStepLoop();
                    btnPause.innerHTML = '<i class="fa-solid fa-pause"></i> Pause';
                    btnPause.className = "btn w-full py-3 bg-amber-500 hover:bg-amber-400 rounded-xl font-bold shadow-lg shadow-amber-500/20 flex items-center justify-center gap-2";
                    this.updateStatus('Running...', 'text-blue-400');
                }
            }

            stopSimulation() {
                this.isRunning = false;
                this.isPaused = false;
                clearTimeout(this.simulationTimeout);
                this.agentPos = { ...this.startPos };
                this.path = []; 
                this.draw();
                this.updateUIForRun(false);
                this.updateStatus('Reset - Ready', 'text-slate-300');
                document.getElementById('stat-steps').innerText = '0';
                document.getElementById('stat-reward').innerText = '0';
                document.getElementById('summary-modal').classList.add('hidden');
            }

            simulationStep() {
                let action = 'stay';
                if (this.mode === 'skill') action = this.getSkillAction();
                else if (this.mode === 'rule') action = this.getRuleAction();
                else if (this.mode === 'knowledge') action = this.getKnowledgeAction();

                const next = this.getNextPos(this.agentPos.x, this.agentPos.y, action);
                this.path.push({ ...this.agentPos });

                if (this.isWall(next.x, next.y)) {
                    this.totalReward -= 5; 
                } else {
                    this.prevPos = { ...this.agentPos };
                    this.agentPos = next;
                    if (this.grid[next.y][next.x] === 2) this.totalReward -= 5; 
                    else this.totalReward -= 1; 
                }
                
                this.steps++;
                this.updateStatsUI();
                this.draw();

                if (this.agentPos.x === this.goalPos.x && this.agentPos.y === this.goalPos.y) {
                    this.finishSimulation(true);
                }
                if (this.steps > 100) {
                     this.finishSimulation(false);
                }
            }

            finishSimulation(success) {
                this.isRunning = false;
                clearTimeout(this.simulationTimeout);
                this.updateUIForRun(false);
                
                if (success) {
                    this.totalReward += 100;
                    this.updateStatus('Goal Reached!', 'text-emerald-400');
                    this.confetti();
                    this.showSummary(true);
                } else {
                    this.updateStatus('Timeout - Robot is lost!', 'text-orange-400');
                    this.showSummary(false);
                }
                this.updateStatsUI();
            }

            // --- Summary / Scaffolding Feedback ---
            showSummary(success) {
                const modal = document.getElementById('summary-modal');
                const title = document.getElementById('summary-title');
                const text = document.getElementById('summary-text');
                const icon = document.getElementById('summary-icon');

                modal.classList.remove('hidden');

                if (this.mode === 'skill') {
                    if (success) {
                        icon.innerText = "üçÄ";
                        title.innerText = "Lucky Guess!";
                        text.innerText = "The robot made it, but mostly by luck. Skill-based reasoning is just reaction‚Äîit has no long-term plan.";
                    } else {
                        icon.innerText = "üòµ‚Äçüí´";
                        title.innerText = "Wandering Aimlessly";
                        text.innerText = "Without a plan, the robot just reacted to walls randomly. It got lost because it didn't know where the goal was.";
                    }
                } else if (this.mode === 'rule') {
                    if (success) {
                        icon.innerText = "üìè";
                        title.innerText = "Logic Prevailed!";
                        text.innerText = "The 'Move Closer' rule worked because the path was simple. Rule-based systems are great when the world is predictable.";
                    } else {
                        icon.innerText = "üõë";
                        title.innerText = "Stuck in a Logic Trap";
                        text.innerText = "The robot got stuck because its rule ('Move Closer') told it to walk into the wall instead of going around. It lacks 'Big Picture' thinking.";
                    }
                } else if (this.mode === 'knowledge') {
                    if (success) {
                        icon.innerText = "üß†";
                        title.innerText = "True Intelligence";
                        text.innerText = "The AI used its training (Q-Table) to find the best path. It ignored traps and mud because it knew the consequences!";
                    } else {
                        icon.innerText = "ü§î";
                        title.innerText = "Needs More Training";
                        text.innerText = "The AI failed. Try increasing the training episodes or tweaking the 'Hate Walls' setting so it learns better.";
                    }
                }
            }

            closeSummary() {
                document.getElementById('summary-modal').classList.add('hidden');
            }

            updateUIForRun(active) {
                const btnRun = document.getElementById('btn-run');
                const btnGroup = document.getElementById('btn-group-active');
                const btnPause = document.getElementById('btn-pause');

                if (active) {
                    btnRun.classList.add('hidden');
                    btnGroup.classList.remove('hidden');
                    btnPause.innerHTML = '<i class="fa-solid fa-pause"></i> Pause';
                    btnPause.className = "btn w-full py-3 bg-amber-500 hover:bg-amber-400 rounded-xl font-bold shadow-lg shadow-amber-500/20 flex items-center justify-center gap-2";
                } else {
                    btnRun.classList.remove('hidden');
                    btnGroup.classList.add('hidden');
                }
            }

            updateStatsUI() {
                document.getElementById('stat-steps').innerText = this.steps;
                document.getElementById('stat-reward').innerText = this.totalReward;
            }

            getNextPos(x, y, action) {
                let nx = x, ny = y;
                if (action === 'up') ny--;
                if (action === 'down') ny++;
                if (action === 'left') nx--;
                if (action === 'right') nx++;
                return {x: nx, y: ny};
            }

            isWall(x, y) {
                if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return true;
                return this.grid[y][x] === 1;
            }

            setMode(mode) {
                if (this.isRunning) this.stopSimulation();
                this.mode = mode;
                
                ['skill', 'rule', 'knowledge'].forEach(m => {
                    const btn = document.getElementById(`btn-${m}`);
                    const isActive = m === mode;
                    if(isActive) {
                        btn.className = "btn w-full p-3 rounded-xl border-2 border-blue-500 bg-blue-500/10 text-left transition-colors relative overflow-hidden";
                    } else {
                        btn.className = "btn w-full p-3 rounded-xl border border-slate-600 hover:bg-slate-700 text-left transition-colors group";
                    }
                });

                const title = document.getElementById('desc-title');
                const text = document.getElementById('desc-text');
                const trainControls = document.getElementById('training-controls');
                
                const tweaksPanel = document.getElementById('tweaks-panel');
                const tweaksSkill = document.getElementById('tweaks-skill');
                const tweaksRule = document.getElementById('tweaks-rule');
                const tweaksKnowledge = document.getElementById('tweaks-knowledge');

                trainControls.classList.add('hidden');
                tweaksPanel.classList.add('hidden');
                tweaksSkill.classList.add('hidden');
                tweaksRule.classList.add('hidden');
                tweaksKnowledge.classList.add('hidden');

                if (mode === 'skill') {
                    title.innerText = "Skill-Based (The Baby Bot)";
                    title.className = "font-bold mb-2 text-green-400";
                    text.innerText = "This robot has no plan. It uses basic reflexes to avoid walking directly into walls, but it moves randomly. It struggles to find the goal unless it's nearby.";
                    tweaksPanel.classList.remove('hidden');
                    tweaksSkill.classList.remove('hidden');

                } else if (mode === 'rule') {
                    title.innerText = "Rule-Based (The Logic Bot)";
                    title.className = "font-bold mb-2 text-yellow-400";
                    text.innerText = "This robot follows a strict rule: 'Always move to the square closest to the goal.' Check 'Fear Mud' to make it smarter!";
                    tweaksPanel.classList.remove('hidden');
                    tweaksRule.classList.remove('hidden');

                } else if (mode === 'knowledge') {
                    title.innerText = "Knowledge-Based (The AI)";
                    title.className = "font-bold mb-2 text-blue-400";
                    text.innerText = "This uses Reinforcement Learning (Q-Learning). It explores the map thousands of times in its 'mind'. Use tweaks to change its personality before training!";
                    trainControls.classList.remove('hidden');
                    tweaksPanel.classList.remove('hidden');
                    tweaksKnowledge.classList.remove('hidden');
                }
                
                if (mode !== 'knowledge') this.draw();
                else if (this.isTrained) this.draw();
            }

            setTool(t) {
                this.tool = t;
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('ring-2', 'ring-blue-400', 'active-tool'));
                document.getElementById(`tool-${t}`).classList.add('ring-2', 'ring-blue-400', 'active-tool');
            }

            setupInputs() {
                let isDragging = false;
                
                const handleStart = (e) => {
                    isDragging = true;
                    this.handleInput(e);
                };
                const handleMove = (e) => {
                    if (isDragging) this.handleInput(e);
                };
                const handleEnd = () => isDragging = false;

                this.canvas.addEventListener('mousedown', handleStart);
                this.canvas.addEventListener('mousemove', handleMove);
                window.addEventListener('mouseup', handleEnd);

                this.canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleStart(e.touches[0]); }, {passive:false});
                this.canvas.addEventListener('touchmove', (e) => { e.preventDefault(); handleMove(e.touches[0]); }, {passive:false});
            }

            handleInput(e) {
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                
                const x = Math.floor((e.clientX - rect.left) * scaleX / CELL_SIZE);
                const y = Math.floor((e.clientY - rect.top) * scaleY / CELL_SIZE);

                if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
                    if ((x===this.startPos.x && y===this.startPos.y) || (x===this.goalPos.x && y===this.goalPos.y)) return;

                    if (this.tool === 'wall') this.grid[y][x] = 1;
                    else if (this.tool === 'mud') this.grid[y][x] = 2;
                    else if (this.tool === 'eraser') this.grid[y][x] = 0;
                    
                    if (this.isTrained) {
                        this.isTrained = false;
                        this.updateStatus('Map changed! Retrain AI.', 'text-yellow-400');
                        document.getElementById('train-bar').style.width = '0%';
                        document.getElementById('train-episode').innerText = '0 eps';
                        document.getElementById('btn-train').innerHTML = '<i class="fa-solid fa-graduation-cap"></i> Train AI';
                    }
                    this.draw();
                }
            }

            resetGrid() {
                this.stopSimulation();
                this.initGrid();
                this.isTrained = false;
                this.path = [];
                this.agentPos = { ...this.startPos };
                document.getElementById('train-bar').style.width = '0%';
                document.getElementById('train-episode').innerText = '0 eps';
                this.draw();
            }

            updateStatus(msg, colorClass) {
                const el = document.getElementById('status-badge');
                el.innerText = msg;
                el.className = `px-3 py-1 rounded-full bg-slate-800 border border-slate-700 text-xs font-mono ${colorClass}`;
            }

            loop() {
                requestAnimationFrame(() => this.loop());
            }
            
            confetti() {
                for(let i=0; i<50; i++) {
                    const p = document.createElement('div');
                    p.style.position = 'absolute';
                    p.style.left = '50%';
                    p.style.top = '50%';
                    p.style.width = '8px';
                    p.style.height = '8px';
                    p.style.backgroundColor = ['#f472b6', '#34d399', '#60a5fa', '#fbbf24'][Math.floor(Math.random()*4)];
                    p.style.transition = 'all 1s ease-out';
                    p.style.zIndex = '100';
                    document.body.appendChild(p);
                    
                    setTimeout(() => {
                        const x = (Math.random() - 0.5) * window.innerWidth;
                        const y = (Math.random() - 0.5) * window.innerHeight;
                        p.style.transform = `translate(${x}px, ${y}px) rotate(${Math.random()*360}deg)`;
                        p.style.opacity = '0';
                    }, 10);
                    
                    setTimeout(() => p.remove(), 1000);
                }
            }
        }

        const app = new RoboApp();

    </script>
</body>
</html>
