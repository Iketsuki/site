<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Robo-Academy: AI Reasoning Lab</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Fredoka:wght@300;400;600&family=JetBrains+Mono:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Fredoka', sans-serif;
            background-color: #0f172a;
            color: #e2e8f0;
            overflow-x: hidden;
        }
        
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }

        .glass-panel {
            background: rgba(30, 41, 59, 0.7);
            backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
        }

        canvas {
            image-rendering: pixelated; /* Sharp rendering for grid */
            cursor: pointer;
            touch-action: none;
        }

        .btn {
            transition: all 0.2s;
            position: relative;
            overflow: hidden;
        }
        .btn:active { transform: scale(0.95); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        .btn::after {
            content: '';
            position: absolute;
            top: 50%; left: 50%;
            width: 0; height: 0;
            background: rgba(255,255,255,0.2);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            transition: width 0.3s, height 0.3s;
        }
        .btn:active::after { width: 200px; height: 200px; }

        .stat-card {
            background: rgba(15, 23, 42, 0.6);
            border-radius: 8px;
            padding: 0.75rem;
            border: 1px solid rgba(255,255,255,0.05);
        }

        /* Checkbox Toggles */
        .toggle-checkbox:checked {
            right: 0;
            border-color: #3b82f6;
        }
        .toggle-checkbox:checked + .toggle-label {
            background-color: #3b82f6;
        }
        .toggle-checkbox:checked + .toggle-label:before {
            transform: translateX(100%);
        }

        /* Range Slider */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #3b82f6;
            margin-top: -6px;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(59, 130, 246, 0.5);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            background: #334155;
            border-radius: 2px;
        }

        /* Animations */
        @keyframes pulse-glow {
            0%, 100% { box-shadow: 0 0 15px rgba(56, 189, 248, 0.2); }
            50% { box-shadow: 0 0 25px rgba(56, 189, 248, 0.5); }
        }
        .animate-glow { animation: pulse-glow 2s infinite; }
        
        .grid-overlay {
            background-image: linear-gradient(rgba(255, 255, 255, 0.05) 1px, transparent 1px),
            linear-gradient(90deg, rgba(255, 255, 255, 0.05) 1px, transparent 1px);
            background-size: 20px 20px;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col lg:flex-row">

    <!-- Sidebar Controls -->
    <div class="w-full lg:w-96 p-4 lg:p-6 flex flex-col gap-4 z-10 lg:h-screen lg:overflow-y-auto glass-panel border-r border-slate-700">
        
        <div class="mb-2">
            <h1 class="text-3xl font-bold bg-gradient-to-r from-blue-400 to-purple-400 bg-clip-text text-transparent">Robo-Academy</h1>
            <p class="text-slate-400 text-sm">Teach AI to think!</p>
        </div>

        <!-- Reasoning Level Selector -->
        <div class="space-y-3">
            <h2 class="text-sm font-semibold uppercase tracking-wider text-slate-400">Select Reasoning Level</h2>
            
            <!-- Level 1: Skill -->
            <button onclick="app.setMode('skill')" id="btn-skill" class="btn w-full p-3 rounded-xl border border-slate-600 hover:bg-slate-700 text-left transition-colors group">
                <div class="flex items-center gap-3">
                    <div class="w-10 h-10 rounded-lg bg-green-500/20 text-green-400 flex items-center justify-center text-xl">
                        <i class="fa-solid fa-bolt"></i>
                    </div>
                    <div>
                        <div class="font-bold text-green-400">Skill-Based</div>
                        <div class="text-xs text-slate-400">Instinctive & Fast</div>
                    </div>
                </div>
            </button>

            <!-- Level 2: Rule -->
            <button onclick="app.setMode('rule')" id="btn-rule" class="btn w-full p-3 rounded-xl border border-slate-600 hover:bg-slate-700 text-left transition-colors group">
                <div class="flex items-center gap-3">
                    <div class="w-10 h-10 rounded-lg bg-yellow-500/20 text-yellow-400 flex items-center justify-center text-xl">
                        <i class="fa-solid fa-scroll"></i>
                    </div>
                    <div>
                        <div class="font-bold text-yellow-400">Rule-Based</div>
                        <div class="text-xs text-slate-400">Follows Logic/Heuristics</div>
                    </div>
                </div>
            </button>

            <!-- Level 3: Knowledge -->
            <button onclick="app.setMode('knowledge')" id="btn-knowledge" class="btn w-full p-3 rounded-xl border-2 border-blue-500 bg-blue-500/10 text-left transition-colors group relative overflow-hidden">
                <div class="absolute inset-0 bg-blue-500/5 group-hover:bg-blue-500/10 transition-colors"></div>
                <div class="flex items-center gap-3 relative z-10">
                    <div class="w-10 h-10 rounded-lg bg-blue-500/20 text-blue-400 flex items-center justify-center text-xl">
                        <i class="fa-solid fa-brain"></i>
                    </div>
                    <div>
                        <div class="font-bold text-blue-400">Knowledge-Based</div>
                        <div class="text-xs text-blue-200">Reinforcement Learning</div>
                    </div>
                </div>
            </button>
        </div>

        <!-- Brain Tweaks (Interactive Rules) -->
        <div id="tweaks-panel" class="glass-panel p-4 bg-slate-800/50 hidden">
            <h3 class="font-bold mb-3 text-sm text-slate-200 flex items-center gap-2">
                <i class="fa-solid fa-sliders"></i> Brain Tweaks
            </h3>
            
            <!-- Skill Mode Tweaks -->
            <div id="tweaks-skill" class="space-y-4 hidden">
                <div>
                    <label class="flex items-center justify-between cursor-pointer">
                        <span class="text-sm text-slate-300 font-bold">Survival Instinct</span>
                        <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                            <input type="checkbox" id="check-survival" class="toggle-checkbox absolute block w-5 h-5 rounded-full bg-white border-4 appearance-none cursor-pointer border-slate-600"/>
                            <label for="check-survival" class="toggle-label block overflow-hidden h-5 rounded-full bg-slate-600 cursor-pointer"></label>
                        </div>
                    </label>
                    <p class="text-[10px] text-slate-400 mt-1 leading-tight">If ON, the robot will never randomly walk into a wall. It forces 'safe' moves only.</p>
                </div>
                <div>
                    <label class="flex items-center justify-between cursor-pointer">
                        <span class="text-sm text-slate-300 font-bold">Hyperactive</span>
                        <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                            <input type="checkbox" id="check-hyper" class="toggle-checkbox absolute block w-5 h-5 rounded-full bg-white border-4 appearance-none cursor-pointer border-slate-600"/>
                            <label for="check-hyper" class="toggle-label block overflow-hidden h-5 rounded-full bg-slate-600 cursor-pointer"></label>
                        </div>
                    </label>
                    <p class="text-[10px] text-slate-400 mt-1 leading-tight">If ON, the robot ignores safety more often and moves randomly.</p>
                </div>
            </div>

            <!-- Rule Mode Tweaks -->
            <div id="tweaks-rule" class="space-y-4 hidden">
                <div>
                    <label class="flex items-center justify-between cursor-pointer">
                        <span class="text-sm text-slate-300 font-bold">Fear Mud?</span>
                        <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                            <input type="checkbox" id="check-fear-mud" class="toggle-checkbox absolute block w-5 h-5 rounded-full bg-white border-4 appearance-none cursor-pointer border-slate-600"/>
                            <label for="check-fear-mud" class="toggle-label block overflow-hidden h-5 rounded-full bg-slate-600 cursor-pointer"></label>
                        </div>
                    </label>
                    <p class="text-[10px] text-slate-400 mt-1 leading-tight">If ON, the robot sees Mud as an obstacle (high cost) and will try to go around it.</p>
                </div>
                <div>
                    <label class="flex items-center justify-between cursor-pointer">
                        <span class="text-sm text-slate-300 font-bold">No Backtracking?</span>
                        <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                            <input type="checkbox" id="check-no-back" class="toggle-checkbox absolute block w-5 h-5 rounded-full bg-white border-4 appearance-none cursor-pointer border-slate-600"/>
                            <label for="check-no-back" class="toggle-label block overflow-hidden h-5 rounded-full bg-slate-600 cursor-pointer"></label>
                        </div>
                    </label>
                    <p class="text-[10px] text-slate-400 mt-1 leading-tight">If ON, the robot remembers its last step and won't immediately return to it. Helps avoid getting stuck in loops.</p>
                </div>
            </div>

            <!-- Knowledge Mode Tweaks -->
            <div id="tweaks-knowledge" class="space-y-4 hidden">
                <div>
                    <div class="flex justify-between items-center mb-1">
                        <span class="text-sm text-slate-300 font-bold">Training Time</span>
                        <span id="episodes-val" class="text-xs text-blue-400 font-mono">1500 eps</span>
                    </div>
                    <input type="range" id="slider-episodes" min="100" max="5000" step="100" value="1500" oninput="document.getElementById('episodes-val').innerText = this.value + ' eps'">
                    <p class="text-[10px] text-slate-400 mt-1 leading-tight">More episodes = smarter bot, but takes longer to train. Low episodes might leave the bot confused.</p>
                </div>
                
                <div>
                    <label class="flex items-center justify-between cursor-pointer">
                        <span class="text-sm text-slate-300 font-bold">Hate Mud</span>
                        <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                            <input type="checkbox" id="check-hate-mud" class="toggle-checkbox absolute block w-5 h-5 rounded-full bg-white border-4 appearance-none cursor-pointer border-slate-600"/>
                            <label for="check-hate-mud" class="toggle-label block overflow-hidden h-5 rounded-full bg-slate-600 cursor-pointer"></label>
                        </div>
                    </label>
                    <p class="text-[10px] text-slate-400 mt-1 leading-tight">Increases punishment for stepping in mud during training.</p>
                </div>

                <div>
                    <label class="flex items-center justify-between cursor-pointer">
                        <span class="text-sm text-slate-300 font-bold">Hate Walls</span>
                        <div class="relative inline-block w-10 mr-2 align-middle select-none transition duration-200 ease-in">
                            <input type="checkbox" id="check-hate-walls" class="toggle-checkbox absolute block w-5 h-5 rounded-full bg-white border-4 appearance-none cursor-pointer border-slate-600"/>
                            <label for="check-hate-walls" class="toggle-label block overflow-hidden h-5 rounded-full bg-slate-600 cursor-pointer"></label>
                        </div>
                    </label>
                    <p class="text-[10px] text-slate-400 mt-1 leading-tight">Increases punishment for hitting walls during training.</p>
                </div>
            </div>
        </div>

        <!-- Description Box -->
        <div class="glass-panel p-4 bg-slate-800/50">
            <h3 id="desc-title" class="font-bold mb-2 text-blue-300">Knowledge-Based (AI)</h3>
            <p id="desc-text" class="text-sm text-slate-300 leading-relaxed">
                The agent simulates thousands of runs (episodes) to learn the entire map. It discovers that mud is slow and walls are blocked, eventually finding the true optimal path through in-depth analysis.
            </p>
        </div>

        <!-- Map Editor Tools -->
        <div class="space-y-2">
            <h2 class="text-sm font-semibold uppercase tracking-wider text-slate-400">Map Editor</h2>
            <div class="grid grid-cols-4 gap-2">
                <button onclick="app.setTool('wall')" class="btn tool-btn bg-slate-700 hover:bg-slate-600 p-2 rounded-lg flex flex-col items-center gap-1 active-tool ring-2 ring-blue-400" id="tool-wall">
                    <span class="text-xl">üß±</span>
                    <span class="text-[10px]">Wall</span>
                </button>
                <button onclick="app.setTool('mud')" class="btn tool-btn bg-slate-700 hover:bg-slate-600 p-2 rounded-lg flex flex-col items-center gap-1" id="tool-mud">
                    <span class="text-xl">üêå</span>
                    <span class="text-[10px]">Mud</span>
                </button>
                <button onclick="app.setTool('eraser')" class="btn tool-btn bg-slate-700 hover:bg-slate-600 p-2 rounded-lg flex flex-col items-center gap-1" id="tool-eraser">
                    <span class="text-xl">ü´ß</span>
                    <span class="text-[10px]">Eraser</span>
                </button>
                <button onclick="app.resetGrid()" class="btn bg-red-900/30 hover:bg-red-900/50 text-red-400 p-2 rounded-lg flex flex-col items-center gap-1">
                    <i class="fa-solid fa-trash text-lg"></i>
                    <span class="text-[10px]">Clear</span>
                </button>
            </div>
        </div>

        <!-- Action Buttons -->
        <div class="mt-auto space-y-3">
             <div id="training-controls" class="hidden">
                <div class="flex justify-between text-xs mb-1 text-slate-400">
                    <span>Training Progress</span>
                    <span id="train-episode">0 eps</span>
                </div>
                <div class="w-full bg-slate-700 rounded-full h-2 mb-3 overflow-hidden">
                    <div id="train-bar" class="bg-blue-500 h-2 rounded-full transition-all duration-75" style="width: 0%"></div>
                </div>
                <button onclick="app.trainAgent()" id="btn-train" class="btn w-full py-3 bg-indigo-600 hover:bg-indigo-500 rounded-xl font-bold shadow-lg shadow-indigo-500/20 flex items-center justify-center gap-2">
                    <i class="fa-solid fa-graduation-cap"></i> Train AI
                </button>
             </div>

             <!-- Simulation Controls Container -->
            <div id="simulation-controls" class="w-full">
                <!-- Initial Run Button -->
                <button onclick="app.runSimulation()" id="btn-run" class="btn w-full py-3 bg-emerald-600 hover:bg-emerald-500 rounded-xl font-bold shadow-lg shadow-emerald-500/20 flex items-center justify-center gap-2">
                    <i class="fa-solid fa-play"></i> Run Simulation
                </button>

                <!-- Active Controls (Pause/Reset) - Hidden by default -->
                <div id="btn-group-active" class="hidden grid grid-cols-2 gap-2">
                    <button onclick="app.togglePause()" id="btn-pause" class="btn w-full py-3 bg-amber-500 hover:bg-amber-400 rounded-xl font-bold shadow-lg shadow-amber-500/20 flex items-center justify-center gap-2">
                        <i class="fa-solid fa-pause"></i> Pause
                    </button>
                    <button onclick="app.stopSimulation()" id="btn-stop" class="btn w-full py-3 bg-red-500 hover:bg-red-400 rounded-xl font-bold shadow-lg shadow-red-500/20 flex items-center justify-center gap-2">
                        <i class="fa-solid fa-stop"></i> Reset
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Viewport -->
    <div class="flex-1 p-2 lg:p-8 flex flex-col items-center justify-center bg-[#0b1120] relative overflow-hidden">
        <!-- Background Decor -->
        <div class="absolute top-0 left-0 w-full h-full grid-overlay opacity-30 pointer-events-none"></div>
        <div class="absolute top-10 right-10 w-64 h-64 bg-blue-500/10 rounded-full blur-3xl pointer-events-none"></div>

        <!-- Header for Canvas -->
        <div class="flex justify-between items-center w-full max-w-2xl mb-4 z-10">
            <div class="flex gap-4 text-sm font-mono">
                <div class="flex items-center gap-2"><span class="w-3 h-3 rounded-full bg-blue-500"></span> Start</div>
                <div class="flex items-center gap-2"><span class="w-3 h-3 rounded-full bg-red-500"></span> Goal</div>
            </div>
            <div id="status-badge" class="px-3 py-1 rounded-full bg-slate-800 border border-slate-700 text-xs font-mono text-slate-300">
                Ready
            </div>
        </div>

        <!-- Canvas Container -->
        <div class="relative canvas-container group">
            <canvas id="gridCanvas" width="600" height="600" class="shadow-2xl shadow-black/50"></canvas>
            
            <!-- Floating Stats (visible on hover or run) -->
            <div class="absolute -right-32 top-0 flex flex-col gap-2 transition-opacity duration-300 opacity-100 lg:opacity-100">
                <div class="stat-card w-28">
                    <div class="text-[10px] uppercase text-slate-500 font-bold">Steps</div>
                    <div id="stat-steps" class="text-xl font-mono text-white">0</div>
                </div>
                <div class="stat-card w-28">
                    <div class="text-[10px] uppercase text-slate-500 font-bold">Reward</div>
                    <div id="stat-reward" class="text-xl font-mono text-emerald-400">0</div>
                </div>
            </div>
        </div>
        
        <div class="mt-6 text-center max-w-lg text-slate-400 text-sm z-10">
            <i class="fa-solid fa-mouse pointer-events-none mr-1"></i> Click & Drag to draw walls. 
            <span class="hidden lg:inline">Right click to erase.</span>
        </div>

    </div>

    <script>
        // --- Configuration & Constants ---
        const GRID_SIZE = 15;
        const CELL_SIZE = 40; // Desktop default, will scale
        const COLORS = {
            empty: '#1e293b',
            wall: '#94a3b8',
            mud: '#451a03', // Dark brown
            start: '#3b82f6',
            goal: '#ef4444',
            path: '#eab308', // Yellow path trace
            visited: 'rgba(100, 116, 139, 0.2)',
            agent: '#fbbf24'
        };

        // --- Game Logic ---
        class RoboApp {
            constructor() {
                this.canvas = document.getElementById('gridCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.grid = [];
                this.mode = 'knowledge'; // skill, rule, knowledge
                this.tool = 'wall';
                this.isDrawing = false;
                this.startPos = {x: 1, y: 1};
                this.goalPos = {x: 13, y: 13};
                this.agentPos = { ...this.startPos };
                this.prevPos = { ...this.startPos }; // For no-backtracking
                this.path = []; // Store path history
                
                this.isRunning = false;
                this.isPaused = false;
                this.simulationTimer = null;
                
                this.qTable = {}; // Map string(x,y) -> {up, down, left, right}
                this.isTrained = false;
                
                // Stats
                this.steps = 0;
                this.totalReward = 0;

                this.resizeCanvas();
                this.initGrid();
                this.setupInputs();
                this.loop();
                this.setMode('knowledge'); // Default
            }

            initGrid() {
                this.grid = [];
                for(let y=0; y<GRID_SIZE; y++) {
                    let row = [];
                    for(let x=0; x<GRID_SIZE; x++) {
                        row.push(0); // 0: empty, 1: wall, 2: mud
                    }
                    this.grid.push(row);
                }
                // Default walls for interest
                this.grid[5][5] = 1; this.grid[5][6] = 1; this.grid[5][7] = 1;
                this.grid[6][5] = 1; this.grid[7][5] = 1;
                // Some mud
                this.grid[10][10] = 2; this.grid[10][11] = 2; this.grid[11][10] = 2;
            }

            resizeCanvas() {
                // Responsive canvas logic could go here
                // For now fixed size logic, scaled via CSS
            }

            // --- Drawing ---
            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                // 1. Draw Grid
                for(let y=0; y<GRID_SIZE; y++) {
                    for(let x=0; x<GRID_SIZE; x++) {
                        let type = this.grid[y][x];
                        let color = COLORS.empty;
                        
                        if (type === 1) color = COLORS.wall;
                        if (type === 2) color = COLORS.mud;
                        if (x === this.startPos.x && y === this.startPos.y) color = COLORS.start;
                        if (x === this.goalPos.x && y === this.goalPos.y) color = COLORS.goal;

                        this.ctx.fillStyle = color;
                        
                        // Rounded rect for cells
                        let gap = 2;
                        this.ctx.fillRect(x*CELL_SIZE + gap, y*CELL_SIZE + gap, CELL_SIZE - gap*2, CELL_SIZE - gap*2);

                        // Visuals for Mud
                        if(type === 2) {
                            this.ctx.fillStyle = 'rgba(255,255,255,0.1)';
                            this.ctx.font = '20px Arial';
                            this.ctx.textAlign = 'center';
                            this.ctx.textBaseline = 'middle';
                            this.ctx.fillText('üêå', x*CELL_SIZE + CELL_SIZE/2, y*CELL_SIZE + CELL_SIZE/2);
                        }

                        // Visualization for Q-Values (Knowledge Mode Only)
                        if (this.mode === 'knowledge' && this.isTrained && type !== 1) {
                            this.drawQArrows(x, y);
                        }
                    }
                }

                // 2. Draw Path
                if (this.path.length > 1) {
                    this.ctx.beginPath();
                    this.ctx.strokeStyle = COLORS.path;
                    this.ctx.lineWidth = 4;
                    this.ctx.lineJoin = 'round';
                    this.ctx.lineCap = 'round';
                    this.ctx.globalAlpha = 0.6; // Slightly transparent

                    const startX = this.path[0].x * CELL_SIZE + CELL_SIZE/2;
                    const startY = this.path[0].y * CELL_SIZE + CELL_SIZE/2;
                    this.ctx.moveTo(startX, startY);

                    for(let i=1; i<this.path.length; i++) {
                        const px = this.path[i].x * CELL_SIZE + CELL_SIZE/2;
                        const py = this.path[i].y * CELL_SIZE + CELL_SIZE/2;
                        this.ctx.lineTo(px, py);
                    }
                    // Draw to current pos
                    const currX = this.agentPos.x * CELL_SIZE + CELL_SIZE/2;
                    const currY = this.agentPos.y * CELL_SIZE + CELL_SIZE/2;
                    this.ctx.lineTo(currX, currY);

                    this.ctx.stroke();
                    this.ctx.globalAlpha = 1.0;
                }

                // 3. Draw Agent
                const ax = this.agentPos.x * CELL_SIZE + CELL_SIZE/2;
                const ay = this.agentPos.y * CELL_SIZE + CELL_SIZE/2;
                
                this.ctx.fillStyle = COLORS.agent;
                this.ctx.beginPath();
                this.ctx.arc(ax, ay, CELL_SIZE/3, 0, Math.PI*2);
                this.ctx.fill();
                
                // Agent Eyes
                this.ctx.fillStyle = 'black';
                this.ctx.beginPath();
                this.ctx.arc(ax - 5, ay - 2, 2, 0, Math.PI*2);
                this.ctx.arc(ax + 5, ay - 2, 2, 0, Math.PI*2);
                this.ctx.fill();
            }

            drawQArrows(x, y) {
                if (x === this.goalPos.x && y === this.goalPos.y) return;
                const key = `${x},${y}`;
                if (!this.qTable[key]) return;
                
                const actions = this.qTable[key];
                // Find best action
                let bestVal = -Infinity;
                let bestAct = null;
                for(let a in actions) {
                    if (actions[a] > bestVal) {
                        bestVal = actions[a];
                        bestAct = a;
                    }
                }

                if (bestVal > -999) {
                    this.ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    this.ctx.font = '12px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.textBaseline = 'middle';
                    let char = '';
                    if (bestAct === 'up') char = '‚Üë';
                    if (bestAct === 'down') char = '‚Üì';
                    if (bestAct === 'left') char = '‚Üê';
                    if (bestAct === 'right') char = '‚Üí';
                    this.ctx.fillText(char, x*CELL_SIZE + CELL_SIZE/2, y*CELL_SIZE + CELL_SIZE/2);
                }
            }

            // --- Agents Logic ---
            getSkillAction() {
                const survival = document.getElementById('check-survival').checked;
                const hyperactive = document.getElementById('check-hyper').checked;
                const moves = ['up', 'down', 'left', 'right'];
                
                if (hyperactive && Math.random() < 0.5) return moves[Math.floor(Math.random() * moves.length)];

                const validMoves = moves.filter(m => {
                    const next = this.getNextPos(this.agentPos.x, this.agentPos.y, m);
                    return !this.isWall(next.x, next.y);
                });

                if (survival && validMoves.length > 0) return validMoves[Math.floor(Math.random() * validMoves.length)];
                if (validMoves.length > 0 && Math.random() > 0.2) return validMoves[Math.floor(Math.random() * validMoves.length)];
                
                return moves[Math.floor(Math.random() * moves.length)];
            }

            getRuleAction() {
                const fearMud = document.getElementById('check-fear-mud').checked;
                const noBack = document.getElementById('check-no-back').checked;
                const moves = ['up', 'down', 'left', 'right'];
                let bestMove = moves[0];
                let minCost = Infinity;

                moves.sort(() => Math.random() - 0.5);

                let stuck = true;
                for (let m of moves) {
                    const next = this.getNextPos(this.agentPos.x, this.agentPos.y, m);
                    if (this.isWall(next.x, next.y)) continue;
                    
                    if (noBack && next.x === this.prevPos.x && next.y === this.prevPos.y) {
                         if (moves.length > 1) continue; 
                    }

                    stuck = false;
                    let cost = Math.abs(next.x - this.goalPos.x) + Math.abs(next.y - this.goalPos.y);
                    if (fearMud && this.grid[next.y][next.x] === 2) cost += 10;

                    if (cost < minCost) {
                        minCost = cost;
                        bestMove = m;
                    }
                }
                if (stuck) return moves[Math.floor(Math.random()*4)];
                return bestMove;
            }

            getKnowledgeAction() {
                if (!this.isTrained) return 'stop';
                const key = `${this.agentPos.x},${this.agentPos.y}`;
                const actions = this.qTable[key];
                if (!actions) return this.getSkillAction();

                let bestAct = null;
                let maxQ = -Infinity;
                for(let a in actions) {
                    if (actions[a] > maxQ) {
                        maxQ = actions[a];
                        bestAct = a;
                    }
                }
                return bestAct;
            }

            // --- Training ---
            async trainAgent() {
                this.isTrained = false;
                const episodes = parseInt(document.getElementById('slider-episodes').value) || 1500;
                const alpha = 0.5, gamma = 0.9, epsilon = 0.1;
                const hateMud = document.getElementById('check-hate-mud').checked;
                const hateWalls = document.getElementById('check-hate-walls').checked;
                const mudPenalty = hateMud ? -50 : -5;
                const wallPenalty = hateWalls ? -50 : -5;

                this.qTable = {}; 
                for(let y=0; y<GRID_SIZE; y++) {
                    for(let x=0; x<GRID_SIZE; x++) {
                        this.qTable[`${x},${y}`] = {up:0, down:0, left:0, right:0};
                    }
                }

                const btn = document.getElementById('btn-train');
                const bar = document.getElementById('train-bar');
                const epLabel = document.getElementById('train-episode');
                btn.disabled = true;
                btn.innerHTML = '<i class="fa-solid fa-spinner fa-spin"></i> Thinking...';

                let ep = 0;
                const trainChunk = () => {
                    const chunkSize = 50;
                    for(let k=0; k<chunkSize && ep < episodes; k++) {
                        let curr = { ...this.startPos };
                        let steps = 0;
                        while(steps < 100) {
                            let action;
                            if (Math.random() < epsilon) {
                                const moves = ['up','down','left','right'];
                                action = moves[Math.floor(Math.random()*4)];
                            } else {
                                let qs = this.qTable[`${curr.x},${curr.y}`];
                                action = Object.keys(qs).reduce((a, b) => qs[a] > qs[b] ? a : b);
                            }

                            let next = this.getNextPos(curr.x, curr.y, action);
                            let reward = -1; 
                            let isDone = false;
                            
                            if (next.x === this.goalPos.x && next.y === this.goalPos.y) {
                                reward = 100;
                                isDone = true;
                            } else if (this.isWall(next.x, next.y)) {
                                reward = wallPenalty;
                                next = curr; 
                            } else if (this.grid[next.y][next.x] === 2) { 
                                reward = mudPenalty; 
                            }

                            const currKey = `${curr.x},${curr.y}`;
                            const nextKey = `${next.x},${next.y}`;
                            const maxNextQ = Math.max(...Object.values(this.qTable[nextKey]));
                            const currentQ = this.qTable[currKey][action];
                            this.qTable[currKey][action] = currentQ + alpha * (reward + gamma * maxNextQ - currentQ);

                            curr = next;
                            steps++;
                            if (isDone) break;
                        }
                        ep++;
                    }

                    const progress = (ep / episodes) * 100;
                    bar.style.width = `${progress}%`;
                    epLabel.innerText = `${ep} / ${episodes}`;

                    if (ep < episodes) {
                        if (ep % 200 === 0) { this.isTrained = true; this.draw(); }
                        requestAnimationFrame(trainChunk);
                    } else {
                        this.isTrained = true;
                        this.draw();
                        btn.disabled = false;
                        btn.innerHTML = '<i class="fa-solid fa-graduation-cap"></i> Retrain';
                        this.updateStatus('Training Complete! Brain optimized.', 'text-green-400');
                    }
                };
                trainChunk();
            }

            // --- Simulation Logic ---
            runSimulation() {
                if (this.isRunning) return;
                
                if (this.mode === 'knowledge' && !this.isTrained) {
                    this.updateStatus('Please Train the AI first!', 'text-red-400');
                    return;
                }

                // Reset State
                this.isRunning = true;
                this.isPaused = false;
                this.agentPos = { ...this.startPos };
                this.prevPos = { ...this.startPos };
                this.path = []; // Reset path
                this.steps = 0;
                this.totalReward = 0;

                this.updateUIForRun(true);
                this.updateStatus('Running...', 'text-blue-400');
                this.updateStatsUI();

                // Start Loop
                this.startTimer();
            }

            startTimer() {
                if (this.simulationTimer) clearInterval(this.simulationTimer);
                const speed = this.mode === 'knowledge' ? 100 : 200;
                this.simulationTimer = setInterval(() => this.simulationStep(), speed);
            }

            togglePause() {
                if (!this.isRunning) return;
                
                this.isPaused = !this.isPaused;
                const btnPause = document.getElementById('btn-pause');
                
                if (this.isPaused) {
                    clearInterval(this.simulationTimer);
                    btnPause.innerHTML = '<i class="fa-solid fa-play"></i> Resume';
                    btnPause.className = "btn w-full py-3 bg-emerald-500 hover:bg-emerald-400 rounded-xl font-bold shadow-lg shadow-emerald-500/20 flex items-center justify-center gap-2";
                    this.updateStatus('Paused', 'text-amber-400');
                } else {
                    this.startTimer();
                    btnPause.innerHTML = '<i class="fa-solid fa-pause"></i> Pause';
                    btnPause.className = "btn w-full py-3 bg-amber-500 hover:bg-amber-400 rounded-xl font-bold shadow-lg shadow-amber-500/20 flex items-center justify-center gap-2";
                    this.updateStatus('Running...', 'text-blue-400');
                }
            }

            stopSimulation() {
                this.isRunning = false;
                this.isPaused = false;
                clearInterval(this.simulationTimer);
                
                // Reset agent to start
                this.agentPos = { ...this.startPos };
                this.path = []; // Clear path trace
                this.draw();
                
                this.updateUIForRun(false);
                this.updateStatus('Reset - Ready', 'text-slate-300');
                
                // Reset stats UI
                document.getElementById('stat-steps').innerText = '0';
                document.getElementById('stat-reward').innerText = '0';
            }

            simulationStep() {
                // Determine Action
                let action = 'stay';
                if (this.mode === 'skill') action = this.getSkillAction();
                else if (this.mode === 'rule') action = this.getRuleAction();
                else if (this.mode === 'knowledge') action = this.getKnowledgeAction();

                // Move Logic
                const next = this.getNextPos(this.agentPos.x, this.agentPos.y, action);
                
                // Track Path
                this.path.push({ ...this.agentPos });

                if (this.isWall(next.x, next.y)) {
                    this.totalReward -= 5; // Bonk
                } else {
                    this.prevPos = { ...this.agentPos };
                    this.agentPos = next;
                    if (this.grid[next.y][next.x] === 2) this.totalReward -= 5; // Mud
                    else this.totalReward -= 1; // Step
                }
                
                this.steps++;
                this.updateStatsUI();
                this.draw();

                // Check Goal
                if (this.agentPos.x === this.goalPos.x && this.agentPos.y === this.goalPos.y) {
                    this.finishSimulation(true);
                }
                // Check Timeout
                if (this.steps > 100) {
                     this.finishSimulation(false);
                }
            }

            finishSimulation(success) {
                this.isRunning = false;
                clearInterval(this.simulationTimer);
                
                if (success) {
                    this.totalReward += 100;
                    this.confetti();
                    this.updateStatus('Goal Reached!', 'text-emerald-400');
                } else {
                    this.updateStatus('Timeout - Robot is lost!', 'text-orange-400');
                }
                this.updateStatsUI();
                this.updateUIForRun(false);
            }

            updateUIForRun(active) {
                const btnRun = document.getElementById('btn-run');
                const btnGroup = document.getElementById('btn-group-active');
                const btnPause = document.getElementById('btn-pause');

                if (active) {
                    btnRun.classList.add('hidden');
                    btnGroup.classList.remove('hidden');
                    // Reset pause button state just in case
                    btnPause.innerHTML = '<i class="fa-solid fa-pause"></i> Pause';
                    btnPause.className = "btn w-full py-3 bg-amber-500 hover:bg-amber-400 rounded-xl font-bold shadow-lg shadow-amber-500/20 flex items-center justify-center gap-2";
                } else {
                    btnRun.classList.remove('hidden');
                    btnGroup.classList.add('hidden');
                }
            }

            updateStatsUI() {
                document.getElementById('stat-steps').innerText = this.steps;
                document.getElementById('stat-reward').innerText = this.totalReward;
            }

            // --- Helpers ---
            getNextPos(x, y, action) {
                let nx = x, ny = y;
                if (action === 'up') ny--;
                if (action === 'down') ny++;
                if (action === 'left') nx--;
                if (action === 'right') nx++;
                return {x: nx, y: ny};
            }

            isWall(x, y) {
                if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return true;
                return this.grid[y][x] === 1;
            }

            // --- UI Interaction ---
            setMode(mode) {
                if (this.isRunning) this.stopSimulation(); // Auto stop if changing modes
                
                this.mode = mode;
                
                // Update UI Buttons
                ['skill', 'rule', 'knowledge'].forEach(m => {
                    const btn = document.getElementById(`btn-${m}`);
                    const isActive = m === mode;
                    if(isActive) {
                        btn.className = "btn w-full p-3 rounded-xl border-2 border-blue-500 bg-blue-500/10 text-left transition-colors relative overflow-hidden";
                    } else {
                        btn.className = "btn w-full p-3 rounded-xl border border-slate-600 hover:bg-slate-700 text-left transition-colors group";
                    }
                });

                // Update Description & Tweaks Panel
                const title = document.getElementById('desc-title');
                const text = document.getElementById('desc-text');
                const trainControls = document.getElementById('training-controls');
                
                // Config Panels
                const tweaksPanel = document.getElementById('tweaks-panel');
                const tweaksSkill = document.getElementById('tweaks-skill');
                const tweaksRule = document.getElementById('tweaks-rule');
                const tweaksKnowledge = document.getElementById('tweaks-knowledge');

                trainControls.classList.add('hidden');
                tweaksPanel.classList.add('hidden');
                tweaksSkill.classList.add('hidden');
                tweaksRule.classList.add('hidden');
                tweaksKnowledge.classList.add('hidden');

                if (mode === 'skill') {
                    title.innerText = "Skill-Based (The Baby Bot)";
                    title.className = "font-bold mb-2 text-green-400";
                    text.innerText = "This robot has no plan. It uses basic reflexes to avoid walking directly into walls, but it moves randomly. It struggles to find the goal unless it's nearby.";
                    
                    tweaksPanel.classList.remove('hidden');
                    tweaksSkill.classList.remove('hidden');

                } else if (mode === 'rule') {
                    title.innerText = "Rule-Based (The Logic Bot)";
                    title.className = "font-bold mb-2 text-yellow-400";
                    text.innerText = "This robot follows a strict rule: 'Always move to the square closest to the goal.' Check 'Fear Mud' to make it smarter!";
                    
                    tweaksPanel.classList.remove('hidden');
                    tweaksRule.classList.remove('hidden');

                } else if (mode === 'knowledge') {
                    title.innerText = "Knowledge-Based (The AI)";
                    title.className = "font-bold mb-2 text-blue-400";
                    text.innerText = "This uses Reinforcement Learning (Q-Learning). It explores the map thousands of times in its 'mind'. Use tweaks to change its personality before training!";
                    
                    trainControls.classList.remove('hidden');
                    tweaksPanel.classList.remove('hidden');
                    tweaksKnowledge.classList.remove('hidden');
                }
                
                // Clear training vis if switching out
                if (mode !== 'knowledge') this.draw();
                else if (this.isTrained) this.draw();
            }

            setTool(t) {
                this.tool = t;
                document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('ring-2', 'ring-blue-400', 'active-tool'));
                document.getElementById(`tool-${t}`).classList.add('ring-2', 'ring-blue-400', 'active-tool');
            }

            setupInputs() {
                let isDragging = false;
                
                const handleStart = (e) => {
                    isDragging = true;
                    this.handleInput(e);
                };
                const handleMove = (e) => {
                    if (isDragging) this.handleInput(e);
                };
                const handleEnd = () => isDragging = false;

                this.canvas.addEventListener('mousedown', handleStart);
                this.canvas.addEventListener('mousemove', handleMove);
                window.addEventListener('mouseup', handleEnd);

                // Touch support
                this.canvas.addEventListener('touchstart', (e) => { e.preventDefault(); handleStart(e.touches[0]); }, {passive:false});
                this.canvas.addEventListener('touchmove', (e) => { e.preventDefault(); handleMove(e.touches[0]); }, {passive:false});
            }

            handleInput(e) {
                const rect = this.canvas.getBoundingClientRect();
                const scaleX = this.canvas.width / rect.width;
                const scaleY = this.canvas.height / rect.height;
                
                const x = Math.floor((e.clientX - rect.left) * scaleX / CELL_SIZE);
                const y = Math.floor((e.clientY - rect.top) * scaleY / CELL_SIZE);

                if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE) {
                    // Prevent overwriting Start/Goal
                    if ((x===this.startPos.x && y===this.startPos.y) || (x===this.goalPos.x && y===this.goalPos.y)) return;

                    if (this.tool === 'wall') this.grid[y][x] = 1;
                    else if (this.tool === 'mud') this.grid[y][x] = 2;
                    else if (this.tool === 'eraser') this.grid[y][x] = 0;
                    
                    // If map changes, AI knowledge is outdated!
                    if (this.isTrained) {
                        this.isTrained = false;
                        this.updateStatus('Map changed! Retrain AI.', 'text-yellow-400');
                        document.getElementById('train-bar').style.width = '0%';
                        document.getElementById('train-episode').innerText = '0 eps';
                        document.getElementById('btn-train').innerHTML = '<i class="fa-solid fa-graduation-cap"></i> Train AI';
                    }
                    this.draw();
                }
            }

            resetGrid() {
                this.stopSimulation(); // Ensure stop
                this.initGrid();
                this.isTrained = false;
                this.path = [];
                this.agentPos = { ...this.startPos };
                document.getElementById('train-bar').style.width = '0%';
                document.getElementById('train-episode').innerText = '0 eps';
                this.draw();
            }

            updateStatus(msg, colorClass) {
                const el = document.getElementById('status-badge');
                el.innerText = msg;
                el.className = `px-3 py-1 rounded-full bg-slate-800 border border-slate-700 text-xs font-mono ${colorClass}`;
            }

            loop() {
                // Main visual loop if needed, currently draw is event driven + animation frame for training
                requestAnimationFrame(() => this.loop());
            }
            
            confetti() {
                // Simple visual reward
                for(let i=0; i<50; i++) {
                    const p = document.createElement('div');
                    p.style.position = 'absolute';
                    p.style.left = '50%';
                    p.style.top = '50%';
                    p.style.width = '8px';
                    p.style.height = '8px';
                    p.style.backgroundColor = ['#f472b6', '#34d399', '#60a5fa', '#fbbf24'][Math.floor(Math.random()*4)];
                    p.style.transition = 'all 1s ease-out';
                    p.style.zIndex = '100';
                    document.body.appendChild(p);
                    
                    setTimeout(() => {
                        const x = (Math.random() - 0.5) * window.innerWidth;
                        const y = (Math.random() - 0.5) * window.innerHeight;
                        p.style.transform = `translate(${x}px, ${y}px) rotate(${Math.random()*360}deg)`;
                        p.style.opacity = '0';
                    }, 10);
                    
                    setTimeout(() => p.remove(), 1000);
                }
            }
        }

        // Initialize
        const app = new RoboApp();

    </script>
</body>
</html>
